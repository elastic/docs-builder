---
name: Detect Duplicate Issues

on:
  issues:
    types:
      - opened

permissions:
  contents: read
  issues: write
  models: read

jobs:
  detect-duplicates:
    runs-on: ubuntu-latest
    steps:
      - name: Detect potential duplicate issues
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const issueNumber = context.issue.number;
            
            // Get the newly created issue
            const { data: newIssue } = await github.rest.issues.get({
              owner,
              repo,
              issue_number: issueNumber,
            });
            
            // Skip if the issue is a pull request
            if (newIssue.pull_request) {
              console.log('Skipping pull request');
              return;
            }
            
            console.log('Analyzing issue #' + issueNumber + ': "' + newIssue.title + '"');
            
            // Get existing open issues (excluding the current one)
            const { data: existingIssues } = await github.rest.issues.listForRepo({
              owner,
              repo,
              state: 'open',
              per_page: 100,
            });
            
            // Filter out pull requests and the current issue
            const openIssues = existingIssues.filter(issue => 
              !issue.pull_request && issue.number !== issueNumber
            );
            
            console.log('Found ' + openIssues.length + ' existing open issues to compare against');
            
            if (openIssues.length === 0) {
              console.log('No existing issues to compare against');
              return;
            }
            
            // Use GitHub Models to find potential duplicates
            const duplicates = [];
            
            // Pre-filter issues using lightweight text similarity to reduce AI API calls
            const newTitle = newIssue.title.toLowerCase();
            const newBody = (newIssue.body || '').toLowerCase();
            const newTitleWords = newTitle.split(/\s+/).filter(w => w.length > 3);
            
            const candidateIssues = [];
            
            // First pass: quick text similarity to identify candidates
            for (const issue of openIssues) {
              const existingTitle = issue.title.toLowerCase();
              const existingBody = (issue.body || '').toLowerCase();
              
              // Calculate title word overlap
              const titleOverlap = newTitleWords.filter(word => existingTitle.includes(word)).length;
              const titleSimilarity = newTitleWords.length > 0 ? titleOverlap / newTitleWords.length : 0;
              
              // Calculate body keyword overlap for additional context
              const bodyHasKeywords = newTitleWords.some(word => existingBody.includes(word));
              
              // Include if there's significant title similarity or body keywords match
              if (titleSimilarity > 0.3 || bodyHasKeywords) {
                candidateIssues.push({
                  issue,
                  titleSimilarity,
                  quickMatch: titleSimilarity > 0.6 // High confidence for potential duplicates
                });
              }
            }
            
            console.log('Pre-filtered to ' + candidateIssues.length + ' candidate issues from ' + openIssues.length + ' total issues');
            
            // Sort candidates by similarity score (highest first) and limit to top 20 for AI analysis
            candidateIssues.sort((a, b) => b.titleSimilarity - a.titleSimilarity);
            const topCandidates = candidateIssues.slice(0, 20);
            
            if (topCandidates.length === 0) {
              console.log('No candidate issues found after pre-filtering');
              return;
            }
            
            // Process high-confidence matches first (may not need AI)
            for (const candidate of topCandidates) {
              if (candidate.quickMatch) {
                duplicates.push({
                  issue: candidate.issue,
                  similarity: 'medium'
                });
                console.log('Found similar issue (pre-filter): #' + candidate.issue.number + ' - ' + candidate.issue.title);
              }
            }
            
            // Use AI for remaining candidates if we haven't found enough duplicates
            const remainingCandidates = topCandidates.filter(c => !c.quickMatch);
            
            if (remainingCandidates.length > 0 && duplicates.length < 3) {
              // Batch process up to 10 issues in a single AI call for efficiency
              const batchSize = Math.min(10, remainingCandidates.length);
              const batch = remainingCandidates.slice(0, batchSize);
              
              try {
                // Create a single prompt that compares the new issue against multiple existing issues
                let promptContent = 'Compare this NEW ISSUE against the following EXISTING ISSUES and identify which ones are duplicates or similar:\n\n';
                promptContent += 'NEW ISSUE:\n';
                promptContent += 'Title: ' + newIssue.title + '\n';
                promptContent += 'Body: ' + (newIssue.body || 'No description provided') + '\n\n';
                promptContent += 'EXISTING ISSUES TO COMPARE:\n';
                
                batch.forEach((candidate, index) => {
                  promptContent += (index + 1) + '. Issue #' + candidate.issue.number + '\n';
                  promptContent += '   Title: ' + candidate.issue.title + '\n';
                  promptContent += '   Body: ' + (candidate.issue.body || 'No description provided') + '\n\n';
                });
                
                promptContent += 'For each existing issue, respond with the issue number followed by: DUPLICATE, SIMILAR, or DIFFERENT. Example: "1: DUPLICATE, 2: DIFFERENT, 3: SIMILAR"';
                
                // Call GitHub Models API with batch comparison
                const response = await fetch('https://models.inference.ai.azure.com/chat/completions', {
                  method: 'POST',
                  headers: {
                    'Authorization': 'Bearer ' + github.token,
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify({
                    messages: [
                      {
                        role: 'system',
                        content: 'You are an expert at analyzing GitHub issues to detect duplicates. Compare issues and determine if they are likely duplicates. For each comparison, respond with: DUPLICATE (same core problem), SIMILAR (related but different aspects), or DIFFERENT (unrelated). Focus on the core problem being reported.'
                      },
                      {
                        role: 'user',
                        content: promptContent
                      }
                    ],
                    model: 'gpt-4o-mini',
                    temperature: 0.1,
                    max_tokens: 100
                  })
                });
                
                if (response.ok) {
                  const result = await response.json();
                  const analysis = result.choices[0]?.message?.content?.trim();
                  console.log('AI batch analysis result: ' + analysis);
                  
                  // Parse the batch response
                  const lines = analysis.split(/[,\n]/).map(l => l.trim());
                  for (const line of lines) {
                    const match = line.match(/(\d+):\s*(DUPLICATE|SIMILAR|DIFFERENT)/i);
                    if (match) {
                      const issueIndex = parseInt(match[1]) - 1;
                      const classification = match[2].toUpperCase();
                      
                      if (issueIndex >= 0 && issueIndex < batch.length && (classification === 'DUPLICATE' || classification === 'SIMILAR')) {
                        const candidate = batch[issueIndex];
                        duplicates.push({
                          issue: candidate.issue,
                          similarity: classification === 'DUPLICATE' ? 'high' : 'medium'
                        });
                        console.log('Found ' + classification.toLowerCase() + ' issue: #' + candidate.issue.number + ' - ' + candidate.issue.title);
                      }
                    }
                  }
                } else {
                  const errorText = await response.text();
                  console.log('GitHub Models API failed: ' + response.status + ' - ' + errorText);
                  console.log('Falling back to pre-filter results only');
                }
              } catch (error) {
                console.log('Error in batch AI analysis: ' + error.message);
                console.log('Falling back to pre-filter results only');
              }
            }
            
            // Post comment if duplicates found
            if (duplicates.length > 0) {
              const highPriority = duplicates.filter(d => d.similarity === 'high');
              const mediumPriority = duplicates.filter(d => d.similarity === 'medium');
              
              let commentBody = '👋 **Potential duplicate issues detected**\n\n';
              commentBody += 'This issue appears to be similar to existing open issues:\n\n';
              
              if (highPriority.length > 0) {
                commentBody += '### 🚨 Likely Duplicates\n';
                for (const { issue } of highPriority) {
                  commentBody += '- #' + issue.number + ' - [' + issue.title + '](' + issue.html_url + ')\n';
                }
                commentBody += '\n';
              }
              
              if (mediumPriority.length > 0) {
                commentBody += '### 🔍 Similar Issues\n';
                for (const { issue } of mediumPriority) {
                  commentBody += '- #' + issue.number + ' - [' + issue.title + '](' + issue.html_url + ')\n';
                }
                commentBody += '\n';
              }
              
              commentBody += 'Please review these issues to see if your issue is already covered. ';
              commentBody += 'If this is indeed a duplicate, consider closing this issue and contributing to the existing discussion.\n\n';
              commentBody += '---\n';
              commentBody += '*This comment was automatically generated using AI to help identify potential duplicates.*';
              
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: issueNumber,
                body: commentBody,
              });
              
              console.log('Posted comment with ' + duplicates.length + ' potential duplicate(s)');
            } else {
              console.log('No potential duplicates found');
            }