---
name: Detect Duplicate Issues

on:
  issues:
    types:
      - opened

permissions:
  contents: read
  issues: write

jobs:
  detect-duplicates:
    runs-on: ubuntu-latest
    steps:
      - name: Detect potential duplicate issues
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const issueNumber = context.issue.number;
            
            // Get the newly created issue
            const { data: newIssue } = await github.rest.issues.get({
              owner,
              repo,
              issue_number: issueNumber,
            });
            
            // Skip if the issue is a pull request
            if (newIssue.pull_request) {
              console.log('Skipping pull request');
              return;
            }
            
            console.log('Analyzing issue #' + issueNumber + ': "' + newIssue.title + '"');
            
            // Get existing open issues (excluding the current one)
            const { data: existingIssues } = await github.rest.issues.listForRepo({
              owner,
              repo,
              state: 'open',
              per_page: 100,
            });
            
            // Filter out pull requests and the current issue
            const openIssues = existingIssues.filter(issue => 
              !issue.pull_request && issue.number !== issueNumber
            );
            
            console.log('Found ' + openIssues.length + ' existing open issues to compare against');
            
            if (openIssues.length === 0) {
              console.log('No existing issues to compare against');
              return;
            }
            
            // Use GitHub Models to find potential duplicates
            const duplicates = [];
            
            for (const issue of openIssues) {
              try {
                // Create the comparison prompt
                const promptContent = 'Compare these two issues and determine if they describe the same problem or feature request:\n\n' +
                  'NEW ISSUE:\n' +
                  'Title: ' + newIssue.title + '\n' +
                  'Body: ' + (newIssue.body || 'No description provided') + '\n\n' +
                  'EXISTING ISSUE:\n' +
                  'Title: ' + issue.title + '\n' +
                  'Body: ' + (issue.body || 'No description provided') + '\n\n' +
                  'Are these issues duplicates?';
                
                // Call GitHub Models API to compare issues
                const response = await fetch('https://models.inference.ai.azure.com/chat/completions', {
                  method: 'POST',
                  headers: {
                    'Authorization': 'Bearer ' + process.env.GITHUB_TOKEN,
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify({
                    messages: [
                      {
                        role: 'system',
                        content: 'You are an expert at analyzing GitHub issues to detect duplicates. Compare two issues and determine if they are likely duplicates. Respond with only "DUPLICATE" if they are very likely duplicates describing the same core problem, "SIMILAR" if they are related but address different aspects, or "DIFFERENT" if they are unrelated. Focus on the core problem being reported, not just keywords.'
                      },
                      {
                        role: 'user',
                        content: promptContent
                      }
                    ],
                    model: 'gpt-4o',
                    temperature: 0.1,
                    max_tokens: 20
                  })
                });
                
                if (response.ok) {
                  const result = await response.json();
                  const analysis = result.choices[0]?.message?.content?.trim().toUpperCase();
                  
                  if (analysis === 'DUPLICATE' || analysis === 'SIMILAR') {
                    duplicates.push({
                      issue,
                      similarity: analysis === 'DUPLICATE' ? 'high' : 'medium'
                    });
                    console.log('Found ' + analysis.toLowerCase() + ' issue: #' + issue.number + ' - ' + issue.title);
                  }
                } else {
                  console.log('Failed to analyze issue #' + issue.number + ': ' + response.status);
                  // Fallback: basic text similarity for critical keywords
                  const newTitle = newIssue.title.toLowerCase();
                  const existingTitle = issue.title.toLowerCase();
                  const newBody = (newIssue.body || '').toLowerCase();
                  const existingBody = (issue.body || '').toLowerCase();
                  
                  // Simple keyword overlap check as fallback
                  const titleWords = newTitle.split(/\s+/).filter(w => w.length > 3);
                  const titleOverlap = titleWords.filter(word => existingTitle.includes(word)).length;
                  
                  if (titleWords.length > 0 && titleOverlap / titleWords.length > 0.6) {
                    duplicates.push({
                      issue,
                      similarity: 'medium'
                    });
                    console.log('Found similar issue (fallback): #' + issue.number + ' - ' + issue.title);
                  }
                }
              } catch (error) {
                console.log('Error analyzing issue #' + issue.number + ': ' + error.message);
              }
              
              // Add a small delay to avoid rate limiting
              await new Promise(resolve => setTimeout(resolve, 200));
            }
            
            // Post comment if duplicates found
            if (duplicates.length > 0) {
              const highPriority = duplicates.filter(d => d.similarity === 'high');
              const mediumPriority = duplicates.filter(d => d.similarity === 'medium');
              
              let commentBody = 'üëã **Potential duplicate issues detected**\n\n';
              commentBody += 'This issue appears to be similar to existing open issues:\n\n';
              
              if (highPriority.length > 0) {
                commentBody += '### üö® Likely Duplicates\n';
                for (const { issue } of highPriority) {
                  commentBody += '- #' + issue.number + ' - [' + issue.title + '](' + issue.html_url + ')\n';
                }
                commentBody += '\n';
              }
              
              if (mediumPriority.length > 0) {
                commentBody += '### üîç Similar Issues\n';
                for (const { issue } of mediumPriority) {
                  commentBody += '- #' + issue.number + ' - [' + issue.title + '](' + issue.html_url + ')\n';
                }
                commentBody += '\n';
              }
              
              commentBody += 'Please review these issues to see if your issue is already covered. ';
              commentBody += 'If this is indeed a duplicate, consider closing this issue and contributing to the existing discussion.\n\n';
              commentBody += '---\n';
              commentBody += '*This comment was automatically generated using AI to help identify potential duplicates.*';
              
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: issueNumber,
                body: commentBody,
              });
              
              console.log('Posted comment with ' + duplicates.length + ' potential duplicate(s)');
            } else {
              console.log('No potential duplicates found');
            }