// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information

using Elastic.Documentation;
using Elastic.Documentation.Configuration.Assembler;
using Elastic.Documentation.Configuration.ReleaseNotes;
using Elastic.Documentation.Extensions;
using Elastic.Documentation.ReleaseNotes;
using Elastic.Markdown.Diagnostics;

namespace Elastic.Markdown.Myst.Directives.Changelog;

/// <summary>
/// A directive block that reads all changelog bundles from a folder and renders them inline,
/// ordered by version (descending). Supports both semver (e.g., "9.3.0") and date-based
/// versions (e.g., "2025-08-05") for Serverless and similar release strategies.
/// </summary>
/// <remarks>
/// Usage:
/// <code>
/// :::{changelog}
/// :::
/// </code>
///
/// Or with a custom bundles folder:
/// <code>
/// :::{changelog} /path/to/bundles
/// :::
/// </code>
///
/// Default bundles folder is <c>changelog/bundles/</c> relative to the docset root.
/// </remarks>
public class ChangelogBlock(DirectiveBlockParser parser, ParserContext context) : DirectiveBlock(parser, context)
{
	/// <summary>
	/// Default folder for changelog bundles, relative to the documentation source directory.
	/// </summary>
	private const string DefaultBundlesFolder = "changelog/bundles";

	public override string Directive => "changelog";

	public ParserContext Context { get; } = context;

	/// <summary>
	/// The resolved absolute path to the bundles folder.
	/// </summary>
	public string? BundlesFolderPath { get; private set; }

	/// <summary>
	/// The path relative to the documentation source directory.
	/// </summary>
	private string? BundlesFolderRelativeToSource { get; set; }

	/// <summary>
	/// Whether the bundles folder was found and contains bundle files.
	/// </summary>
	public bool Found { get; private set; }

	/// <summary>
	/// Loaded and parsed bundles, sorted by version (semver descending).
	/// </summary>
	public IReadOnlyList<LoadedBundle> LoadedBundles { get; private set; } = [];

	/// <summary>
	/// Whether to group entries by area/component within each section.
	/// Defaults to false in order to match CLI behavior.
	/// </summary>
	public bool Subsections { get; private set; }

	/// <summary>
	/// Explicit path to the changelog configuration file, parsed from the :config: option.
	/// If not specified, auto-discovers from docs/changelog.yml or changelog.yml relative to docset root.
	/// </summary>
	public string? ConfigPath { get; private set; }

	/// <summary>
	/// The loaded publish blocker configuration used to filter entries.
	/// If null, no publish filtering is applied.
	/// </summary>
	public PublishBlocker? PublishBlocker { get; private set; }

	/// <summary>
	/// Repository names that are marked as private in assembler.yml.
	/// Links to these repositories will be hidden (commented out) in the rendered output.
	/// Auto-detected from assembler configuration when available.
	/// </summary>
	public HashSet<string> PrivateRepositories { get; private set; } = new(StringComparer.OrdinalIgnoreCase);

	/// <summary>
	/// Returns all anchors that will be generated by this directive during rendering.
	/// </summary>
	public override IEnumerable<string> GeneratedAnchors => ComputeGeneratedAnchors();

	/// <summary>
	/// Returns table of contents items for the right-hand navigation.
	/// </summary>
	public IEnumerable<PageTocItem> GeneratedTableOfContent => ComputeTableOfContent();

	public override void FinalizeAndValidate(ParserContext context)
	{
		ExtractBundlesFolderPath();
		Subsections = PropBool("subsections");
		ConfigPath = Prop("config");
		LoadConfiguration();
		LoadPrivateRepositories();
		if (Found)
			LoadAndCacheBundles();
	}

	private void ExtractBundlesFolderPath()
	{
		var folderPath = Arguments;

		if (string.IsNullOrWhiteSpace(folderPath))
			folderPath = DefaultBundlesFolder;

		BundlesFolderPath = Build.DocumentationSourceDirectory.ResolvePathFrom(folderPath);
		BundlesFolderRelativeToSource = Path.GetRelativePath(Build.DocumentationSourceDirectory.FullName, BundlesFolderPath);

		if (!Build.ReadFileSystem.Directory.Exists(BundlesFolderPath))
		{
			this.EmitError($"Changelog bundles folder `{BundlesFolderRelativeToSource}` does not exist.");
			return;
		}

		var bundles = Build.ReadFileSystem.Directory
			.EnumerateFiles(BundlesFolderPath, "*.yaml")
			.Concat(Build.ReadFileSystem.Directory.EnumerateFiles(BundlesFolderPath, "*.yml"))
			.ToList();

		if (bundles.Count == 0)
		{
			this.EmitError($"Changelog bundles folder `{BundlesFolderRelativeToSource}` contains no YAML files.");
			return;
		}

		Found = true;
	}

	/// <summary>
	/// Loads the changelog configuration to extract publish blockers.
	/// Attempts to load from:
	/// 1. Explicit :config: path if specified
	/// 2. changelog.yml in the docset root
	/// 3. docs/changelog.yml relative to docset root
	/// </summary>
	private void LoadConfiguration()
	{
		var fileSystem = Build.ReadFileSystem;
		string? configPath = null;

		// Try explicit config path first
		if (!string.IsNullOrWhiteSpace(ConfigPath))
		{
			var explicitPath = Build.DocumentationSourceDirectory.ResolvePathFrom(ConfigPath);

			if (fileSystem.File.Exists(explicitPath))
				configPath = explicitPath;
			else
				this.EmitWarning($"Specified changelog config path '{ConfigPath}' not found.");
		}
		else
		{
			// Auto-discover: try changelog.yml first, then docs/changelog.yml
			var changelogYml = Build.DocumentationSourceDirectory.ResolvePathFrom("changelog.yml");
			var docsChangelogYml = Build.DocumentationSourceDirectory.ResolvePathFrom("docs/changelog.yml");

			if (fileSystem.File.Exists(changelogYml))
				configPath = changelogYml;
			else if (fileSystem.File.Exists(docsChangelogYml))
				configPath = docsChangelogYml;
		}

		if (string.IsNullOrWhiteSpace(configPath))
			return;

		PublishBlocker = ReleaseNotesSerialization.LoadPublishBlocker(fileSystem, configPath);
	}

	/// <summary>
	/// Loads private repository names from assembler configuration.
	/// Links to private repositories will be hidden in the rendered output.
	/// </summary>
	private void LoadPrivateRepositories()
	{
		try
		{
			// Try to load assembler configuration to get private repositories
			var assemblerConfig = AssemblyConfiguration.Create(Build.ConfigurationFileProvider);
			foreach (var repoName in assemblerConfig.PrivateRepositories.Keys)
				_ = PrivateRepositories.Add(repoName);
		}
		catch
		{
			// If assembler.yml is not available (standalone builds), no repos are private
			// This is expected behavior - we silently continue with empty private repos
		}
	}

	private void LoadAndCacheBundles()
	{
		if (BundlesFolderPath is null)
			return;

		var loader = new BundleLoader(Build.ReadFileSystem);

		// Load bundles using the BundleLoader service
		var loadedBundles = loader.LoadBundles(
			BundlesFolderPath,
			msg => this.EmitWarning(msg));

		// Sort by version (descending - newest first)
		// Supports both semver (e.g., "9.3.0") and date-based (e.g., "2025-08-05") versions
		var sortedBundles = loadedBundles
			.OrderByDescending(b => VersionOrDate.Parse(b.Version))
			.ToList();

		// Always merge bundles with the same target version
		// (e.g., Cloud Serverless with multiple repos contributing to a single dated release)
		LoadedBundles = loader.MergeBundlesByTarget(sortedBundles);
	}

	private IEnumerable<string> ComputeGeneratedAnchors()
	{
		foreach (var bundle in LoadedBundles)
		{
			var titleSlug = ChangelogTextUtilities.TitleToSlug(bundle.Version);
			var repo = bundle.Repo;

			// Group entries by type to determine which sections will exist
			var entriesByType = bundle.Entries
				.GroupBy(e => e.Type)
				.ToDictionary(g => g.Key, g => g.Count());

			// Critical sections
			if (entriesByType.ContainsKey(ChangelogEntryType.BreakingChange))
				yield return $"{repo}-{titleSlug}-breaking-changes";

			if (entriesByType.ContainsKey(ChangelogEntryType.Security))
				yield return $"{repo}-{titleSlug}-security";

			if (entriesByType.ContainsKey(ChangelogEntryType.KnownIssue))
				yield return $"{repo}-{titleSlug}-known-issues";

			if (entriesByType.ContainsKey(ChangelogEntryType.Deprecation))
				yield return $"{repo}-{titleSlug}-deprecations";

			// Features and enhancements section
			if (entriesByType.ContainsKey(ChangelogEntryType.Feature) ||
				entriesByType.ContainsKey(ChangelogEntryType.Enhancement))
				yield return $"{repo}-{titleSlug}-features-enhancements";

			// Fixes section (bug fixes only, security is separate)
			if (entriesByType.ContainsKey(ChangelogEntryType.BugFix))
				yield return $"{repo}-{titleSlug}-fixes";

			// Documentation section
			if (entriesByType.ContainsKey(ChangelogEntryType.Docs))
				yield return $"{repo}-{titleSlug}-docs";

			// Regressions section
			if (entriesByType.ContainsKey(ChangelogEntryType.Regression))
				yield return $"{repo}-{titleSlug}-regressions";

			// Other changes section
			if (entriesByType.ContainsKey(ChangelogEntryType.Other))
				yield return $"{repo}-{titleSlug}-other";
		}
	}

	private IEnumerable<PageTocItem> ComputeTableOfContent()
	{
		foreach (var bundle in LoadedBundles)
		{
			var titleSlug = ChangelogTextUtilities.TitleToSlug(bundle.Version);
			var repo = bundle.Repo;

			// Version header
			yield return new PageTocItem
			{
				Heading = bundle.Version,
				Slug = titleSlug,
				Level = 2
			};

			// Group entries by type to determine which sections will exist
			var entriesByType = bundle.Entries
				.GroupBy(e => e.Type)
				.ToDictionary(g => g.Key, g => g.Count());

			// Critical sections first (new ordering) - all at h3 level (children of version)
			if (entriesByType.ContainsKey(ChangelogEntryType.BreakingChange))
				yield return new PageTocItem
				{
					Heading = "Breaking changes",
					Slug = $"{repo}-{titleSlug}-breaking-changes",
					Level = 3
				};

			if (entriesByType.ContainsKey(ChangelogEntryType.Security))
				yield return new PageTocItem
				{
					Heading = "Security",
					Slug = $"{repo}-{titleSlug}-security",
					Level = 3
				};

			if (entriesByType.ContainsKey(ChangelogEntryType.KnownIssue))
				yield return new PageTocItem
				{
					Heading = "Known issues",
					Slug = $"{repo}-{titleSlug}-known-issues",
					Level = 3
				};

			if (entriesByType.ContainsKey(ChangelogEntryType.Deprecation))
				yield return new PageTocItem
				{
					Heading = "Deprecations",
					Slug = $"{repo}-{titleSlug}-deprecations",
					Level = 3
				};

			// Features and enhancements section
			if (entriesByType.ContainsKey(ChangelogEntryType.Feature) ||
				entriesByType.ContainsKey(ChangelogEntryType.Enhancement))
				yield return new PageTocItem
				{
					Heading = "Features and enhancements",
					Slug = $"{repo}-{titleSlug}-features-enhancements",
					Level = 3
				};

			// Fixes section (bug fixes only, security is separate)
			if (entriesByType.ContainsKey(ChangelogEntryType.BugFix))
				yield return new PageTocItem
				{
					Heading = "Fixes",
					Slug = $"{repo}-{titleSlug}-fixes",
					Level = 3
				};

			// Documentation section
			if (entriesByType.ContainsKey(ChangelogEntryType.Docs))
				yield return new PageTocItem
				{
					Heading = "Documentation",
					Slug = $"{repo}-{titleSlug}-docs",
					Level = 3
				};

			// Regressions section
			if (entriesByType.ContainsKey(ChangelogEntryType.Regression))
				yield return new PageTocItem
				{
					Heading = "Regressions",
					Slug = $"{repo}-{titleSlug}-regressions",
					Level = 3
				};

			// Other changes section
			if (entriesByType.ContainsKey(ChangelogEntryType.Other))
				yield return new PageTocItem
				{
					Heading = "Other changes",
					Slug = $"{repo}-{titleSlug}-other",
					Level = 3
				};
		}
	}
}
