// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information

using Elastic.Documentation;
using Elastic.Documentation.Configuration.ReleaseNotes;
using Elastic.Documentation.Extensions;
using Elastic.Documentation.ReleaseNotes;
using Elastic.Markdown.Diagnostics;

namespace Elastic.Markdown.Myst.Directives.Changelog;

/// <summary>
/// A directive block that reads all changelog bundles from a folder and renders them inline,
/// ordered by version (descending). Supports both semver (e.g., "9.3.0") and date-based
/// versions (e.g., "2025-08-05") for Serverless and similar release strategies.
/// </summary>
/// <remarks>
/// Usage:
/// <code>
/// :::{changelog}
/// :::
/// </code>
///
/// Or with a custom bundles folder:
/// <code>
/// :::{changelog} /path/to/bundles
/// :::
/// </code>
///
/// Default bundles folder is <c>changelog/bundles/</c> relative to the docset root.
/// </remarks>
public class ChangelogBlock(DirectiveBlockParser parser, ParserContext context) : DirectiveBlock(parser, context)
{
	/// <summary>
	/// Default folder for changelog bundles, relative to the documentation source directory.
	/// </summary>
	private const string DefaultBundlesFolder = "changelog/bundles";

	public override string Directive => "changelog";

	public ParserContext Context { get; } = context;

	/// <summary>
	/// The resolved absolute path to the bundles folder.
	/// </summary>
	public string? BundlesFolderPath { get; private set; }

	/// <summary>
	/// The path relative to the documentation source directory.
	/// </summary>
	private string? BundlesFolderRelativeToSource { get; set; }

	/// <summary>
	/// Whether the bundles folder was found and contains bundle files.
	/// </summary>
	public bool Found { get; private set; }

	/// <summary>
	/// Loaded and parsed bundles, sorted by version (semver descending).
	/// </summary>
	public IReadOnlyList<LoadedBundle> LoadedBundles { get; private set; } = [];

	/// <summary>
	/// Whether to group entries by area/component within each section.
	/// Defaults to false in order to match CLI behavior.
	/// </summary>
	public bool Subsections { get; private set; }

	/// <summary>
	/// Whether to merge bundles that share the same target version/date into a single section.
	/// Useful for Cloud Serverless releases where multiple repos contribute to a single dated release.
	/// Defaults to false.
	/// </summary>
	public bool MergeSameTarget { get; private set; }

	/// <summary>
	/// Explicit path to the changelog configuration file, parsed from the :config: option.
	/// If not specified, auto-discovers from docs/changelog.yml or changelog.yml relative to docset root.
	/// </summary>
	public string? ConfigPath { get; private set; }

	/// <summary>
	/// The loaded publish blocker configuration used to filter entries.
	/// If null, no publish filtering is applied.
	/// </summary>
	public PublishBlocker? PublishBlocker { get; private set; }

	/// <summary>
	/// Whether to hide PR and issue links in the rendered output.
	/// When true, links are commented out. Defaults to false.
	/// </summary>
	public bool HideLinks { get; private set; }

	/// <summary>
	/// Feature IDs to hide from the rendered output.
	/// Entries with matching feature IDs will be filtered out.
	/// Parsed from the :hide-features: option (comma-separated).
	/// </summary>
	public HashSet<string> FeatureIdsToHide { get; private set; } = new(StringComparer.OrdinalIgnoreCase);

	/// <summary>
	/// Returns all anchors that will be generated by this directive during rendering.
	/// </summary>
	public override IEnumerable<string> GeneratedAnchors => ComputeGeneratedAnchors();

	public override void FinalizeAndValidate(ParserContext context)
	{
		ExtractBundlesFolderPath();
		Subsections = PropBool("subsections");
		MergeSameTarget = PropBool("merge");
		HideLinks = PropBool("hide-links");
		ConfigPath = Prop("config");
		ParseHideFeatures();
		LoadConfiguration();
		if (Found)
			LoadAndCacheBundles();
	}

	private void ParseHideFeatures()
	{
		var hideFeatures = Prop("hide-features");
		if (string.IsNullOrWhiteSpace(hideFeatures))
			return;

		foreach (var featureId in hideFeatures.Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries))
			_ = FeatureIdsToHide.Add(featureId);
	}

	private void ExtractBundlesFolderPath()
	{
		var folderPath = Arguments;

		if (string.IsNullOrWhiteSpace(folderPath))
			folderPath = DefaultBundlesFolder;

		BundlesFolderPath = Build.DocumentationSourceDirectory.ResolvePathFrom(folderPath);
		BundlesFolderRelativeToSource = Path.GetRelativePath(Build.DocumentationSourceDirectory.FullName, BundlesFolderPath);

		if (!Build.ReadFileSystem.Directory.Exists(BundlesFolderPath))
		{
			this.EmitError($"Changelog bundles folder `{BundlesFolderRelativeToSource}` does not exist.");
			return;
		}

		var bundles = Build.ReadFileSystem.Directory
			.EnumerateFiles(BundlesFolderPath, "*.yaml")
			.Concat(Build.ReadFileSystem.Directory.EnumerateFiles(BundlesFolderPath, "*.yml"))
			.ToList();

		if (bundles.Count == 0)
		{
			this.EmitError($"Changelog bundles folder `{BundlesFolderRelativeToSource}` contains no YAML files.");
			return;
		}

		Found = true;
	}

	/// <summary>
	/// Loads the changelog configuration to extract publish blockers.
	/// Attempts to load from:
	/// 1. Explicit :config: path if specified
	/// 2. changelog.yml in the docset root
	/// 3. docs/changelog.yml relative to docset root
	/// </summary>
	private void LoadConfiguration()
	{
		var fileSystem = Build.ReadFileSystem;
		string? configPath = null;

		// Try explicit config path first
		if (!string.IsNullOrWhiteSpace(ConfigPath))
		{
			var explicitPath = Build.DocumentationSourceDirectory.ResolvePathFrom(ConfigPath);

			if (fileSystem.File.Exists(explicitPath))
				configPath = explicitPath;
			else
				this.EmitWarning($"Specified changelog config path '{ConfigPath}' not found.");
		}
		else
		{
			// Auto-discover: try changelog.yml first, then docs/changelog.yml
			var changelogYml = Build.DocumentationSourceDirectory.ResolvePathFrom("changelog.yml");
			var docsChangelogYml = Build.DocumentationSourceDirectory.ResolvePathFrom("docs/changelog.yml");

			if (fileSystem.File.Exists(changelogYml))
				configPath = changelogYml;
			else if (fileSystem.File.Exists(docsChangelogYml))
				configPath = docsChangelogYml;
		}

		if (string.IsNullOrWhiteSpace(configPath))
			return;

		PublishBlocker = ReleaseNotesSerialization.LoadPublishBlocker(fileSystem, configPath);
	}

	private void LoadAndCacheBundles()
	{
		if (BundlesFolderPath is null)
			return;

		var loader = new BundleLoader(Build.ReadFileSystem);

		// Load bundles using the BundleLoader service
		var loadedBundles = loader.LoadBundles(
			BundlesFolderPath,
			msg => this.EmitWarning(msg));

		// Sort by version (descending - newest first)
		// Supports both semver (e.g., "9.3.0") and date-based (e.g., "2025-08-05") versions
		var sortedBundles = loadedBundles
			.OrderByDescending(b => VersionOrDate.Parse(b.Version))
			.ToList();

		// Optionally merge bundles with the same target version
		LoadedBundles = MergeSameTarget
			? loader.MergeBundlesByTarget(sortedBundles)
			: sortedBundles;
	}

	private IEnumerable<string> ComputeGeneratedAnchors()
	{
		foreach (var bundle in LoadedBundles)
		{
			var titleSlug = ChangelogTextUtilities.TitleToSlug(bundle.Version);
			var repo = bundle.Repo;

			// Group entries by type to determine which sections will exist
			var entriesByType = bundle.Entries
				.GroupBy(e => e.Type)
				.ToDictionary(g => g.Key, g => g.Count());

			// Features and enhancements section
			if (entriesByType.ContainsKey(ChangelogEntryType.Feature) ||
				entriesByType.ContainsKey(ChangelogEntryType.Enhancement))
				yield return $"{repo}-{titleSlug}-features-enhancements";

			// Fixes section
			if (entriesByType.ContainsKey(ChangelogEntryType.Security) ||
				entriesByType.ContainsKey(ChangelogEntryType.BugFix))
				yield return $"{repo}-{titleSlug}-fixes";

			// Documentation section
			if (entriesByType.ContainsKey(ChangelogEntryType.Docs))
				yield return $"{repo}-{titleSlug}-docs";

			// Regressions section
			if (entriesByType.ContainsKey(ChangelogEntryType.Regression))
				yield return $"{repo}-{titleSlug}-regressions";

			// Other changes section
			if (entriesByType.ContainsKey(ChangelogEntryType.Other))
				yield return $"{repo}-{titleSlug}-other";

			// Breaking changes section
			if (entriesByType.ContainsKey(ChangelogEntryType.BreakingChange))
				yield return $"{repo}-{titleSlug}-breaking-changes";

			// Deprecations section
			if (entriesByType.ContainsKey(ChangelogEntryType.Deprecation))
				yield return $"{repo}-{titleSlug}-deprecations";

			// Known issues section
			if (entriesByType.ContainsKey(ChangelogEntryType.KnownIssue))
				yield return $"{repo}-{titleSlug}-known-issues";
		}
	}
}
