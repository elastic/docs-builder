// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information

using System.Text.RegularExpressions;
using Elastic.Documentation;
using Elastic.Documentation.Changelog;
using Elastic.Documentation.Configuration.Serialization;
using Elastic.Markdown.Diagnostics;
using YamlDotNet.Core;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

namespace Elastic.Markdown.Myst.Directives.Changelog;

/// <summary>
/// Represents a loaded and parsed changelog bundle with its metadata.
/// </summary>
/// <param name="Version">The semantic version extracted from the bundle.</param>
/// <param name="Repo">The repository/product name.</param>
/// <param name="Data">The full parsed bundle data.</param>
/// <param name="FilePath">The absolute path to the bundle file.</param>
/// <param name="Entries">Resolved changelog entries (from inline data or file references).</param>
public record LoadedBundle(
	string Version,
	string Repo,
	BundledChangelogData Data,
	string FilePath,
	IReadOnlyList<ChangelogData> Entries)
{
	/// <summary>
	/// Entries grouped by their changelog entry type.
	/// </summary>
	public IReadOnlyDictionary<ChangelogEntryType, IReadOnlyCollection<ChangelogData>> EntriesByType =>
		Entries
			.GroupBy(e => e.Type)
			.ToDictionary(g => g.Key, g => (IReadOnlyCollection<ChangelogData>)g.ToList().AsReadOnly());
}

/// <summary>
/// A directive block that reads all changelog bundles from a folder and renders them inline,
/// ordered by version number (semver, descending).
/// </summary>
/// <remarks>
/// Usage:
/// <code>
/// :::{changelog}
/// :::
/// </code>
///
/// Or with a custom bundles folder:
/// <code>
/// :::{changelog} /path/to/bundles
/// :::
/// </code>
///
/// Default bundles folder is <c>changelog/bundles/</c> relative to the docset root.
/// </remarks>
public partial class ChangelogBlock(DirectiveBlockParser parser, ParserContext context) : DirectiveBlock(parser, context)
{
	/// <summary>
	/// Default folder for changelog bundles, relative to the documentation source directory.
	/// </summary>
	private const string DefaultBundlesFolder = "changelog/bundles";

	// Regex to normalize "version:" to "target:" in changelog YAML files
	[GeneratedRegex(@"(\s+)version:", RegexOptions.Multiline)]
	private static partial Regex VersionToTargetRegex();

	public override string Directive => "changelog";

	public ParserContext Context { get; } = context;

	/// <summary>
	/// The resolved absolute path to the bundles folder.
	/// </summary>
	public string? BundlesFolderPath { get; private set; }

	/// <summary>
	/// The path relative to the documentation source directory.
	/// </summary>
	private string? BundlesFolderRelativeToSource { get; set; }

	/// <summary>
	/// Whether the bundles folder was found and contains bundle files.
	/// </summary>
	public bool Found { get; private set; }

	/// <summary>
	/// Loaded and parsed bundles, sorted by version (semver descending).
	/// </summary>
	public IReadOnlyList<LoadedBundle> LoadedBundles { get; private set; } = [];

	/// <summary>
	/// Returns all anchors that will be generated by this directive during rendering.
	/// </summary>
	public override IEnumerable<string> GeneratedAnchors => ComputeGeneratedAnchors();

	public override void FinalizeAndValidate(ParserContext context)
	{
		ExtractBundlesFolderPath();
		if (Found)
			LoadAndCacheBundles();
	}

	private void ExtractBundlesFolderPath()
	{
		var folderPath = Arguments;

		if (string.IsNullOrWhiteSpace(folderPath))
			folderPath = DefaultBundlesFolder;

		var resolveFrom = Build.DocumentationSourceDirectory.FullName;
		if (folderPath.StartsWith('/'))
			folderPath = folderPath.TrimStart('/');

		BundlesFolderPath = Path.Combine(resolveFrom, folderPath);
		BundlesFolderRelativeToSource = Path.GetRelativePath(Build.DocumentationSourceDirectory.FullName, BundlesFolderPath);

		if (!Build.ReadFileSystem.Directory.Exists(BundlesFolderPath))
		{
			this.EmitError($"Changelog bundles folder `{BundlesFolderRelativeToSource}` does not exist.");
			return;
		}

		var bundles = Build.ReadFileSystem.Directory
			.EnumerateFiles(BundlesFolderPath, "*.yaml")
			.Concat(Build.ReadFileSystem.Directory.EnumerateFiles(BundlesFolderPath, "*.yml"))
			.ToList();

		if (bundles.Count == 0)
		{
			this.EmitError($"Changelog bundles folder `{BundlesFolderRelativeToSource}` contains no YAML files.");
			return;
		}

		Found = true;
	}

	private void LoadAndCacheBundles()
	{
		if (BundlesFolderPath is null)
			return;

		var fileSystem = Build.ReadFileSystem;
		var deserializer = new StaticDeserializerBuilder(new YamlStaticContext())
			.WithNamingConvention(UnderscoredNamingConvention.Instance)
			.WithTypeConverter(new ChangelogEntryTypeConverter())
			.Build();

		var yamlFiles = fileSystem.Directory
			.EnumerateFiles(BundlesFolderPath, "*.yaml")
			.Concat(fileSystem.Directory.EnumerateFiles(BundlesFolderPath, "*.yml"))
			.ToList();

		var loadedBundles = new List<LoadedBundle>();

		foreach (var bundleFile in yamlFiles)
		{
			var bundleData = LoadBundle(bundleFile, deserializer);
			if (bundleData == null)
				continue;

			var version = GetVersionFromBundle(bundleData) ?? Path.GetFileNameWithoutExtension(bundleFile);
			var repo = bundleData.Products.Count > 0
				? bundleData.Products[0].Product ?? "elastic"
				: "elastic";

			var entries = ResolveEntries(bundleData, bundleFile, deserializer);

			loadedBundles.Add(new LoadedBundle(version, repo, bundleData, bundleFile, entries));
		}

		// Sort by semver (descending - newest first)
		LoadedBundles = loadedBundles
			.OrderByDescending(b => ParseVersion(b.Version))
			.ToList();
	}

	private BundledChangelogData? LoadBundle(string filePath, IDeserializer deserializer)
	{
		try
		{
			var bundleContent = Build.ReadFileSystem.File.ReadAllText(filePath);
			return deserializer.Deserialize<BundledChangelogData>(bundleContent);
		}
		catch (YamlException e)
		{
			var fileName = Path.GetFileName(filePath);
			this.EmitWarning($"Failed to parse changelog bundle '{fileName}': {e.Message}");
			return null;
		}
	}

	private static string? GetVersionFromBundle(BundledChangelogData bundledData) =>
		bundledData.Products.Count > 0 ? bundledData.Products[0].Target : null;

	private static SemVersion ParseVersion(string version) =>
		SemVersion.TryParse(version, out var semVersion) ? semVersion : ZeroVersion.Instance;

	private List<ChangelogData> ResolveEntries(
		BundledChangelogData bundledData,
		string bundleFilePath,
		IDeserializer deserializer)
	{
		var entries = new List<ChangelogData>();
		var bundleDirectory = Path.GetDirectoryName(bundleFilePath)
			?? Build.DocumentationSourceDirectory.FullName;

		// Default changelog directory is parent of bundles folder
		var changelogDirectory = Path.GetDirectoryName(bundleDirectory)
			?? Build.DocumentationSourceDirectory.FullName;

		foreach (var entry in bundledData.Entries)
		{
			ChangelogData? entryData = null;

			// If entry has resolved/inline data, use it directly
			if (!string.IsNullOrWhiteSpace(entry.Title) && !string.IsNullOrWhiteSpace(entry.Type))
			{
				var entryType = ChangelogEntryTypeExtensions.TryParse(entry.Type, out var parsed, ignoreCase: true, allowMatchingMetadataAttribute: true)
					? parsed
					: ChangelogEntryType.Other;

				entryData = new ChangelogData
				{
					Title = entry.Title,
					Type = entryType,
					Subtype = entry.Subtype,
					Description = entry.Description,
					Impact = entry.Impact,
					Action = entry.Action,
					FeatureId = entry.FeatureId,
					Highlight = entry.Highlight,
					Pr = entry.Pr,
					Products = entry.Products ?? [],
					Areas = entry.Areas,
					Issues = entry.Issues
				};
			}
			else if (!string.IsNullOrWhiteSpace(entry.File?.Name))
			{
				// Load from file reference - look in changelog directory (parent of bundles)
				var filePath = Path.Combine(changelogDirectory, entry.File.Name);

				if (!Build.ReadFileSystem.File.Exists(filePath))
				{
					this.EmitWarning($"Referenced changelog file '{entry.File.Name}' not found at '{filePath}'.");
					continue;
				}

				try
				{
					var fileContent = Build.ReadFileSystem.File.ReadAllText(filePath);

					// Skip comment lines and normalize version to target
					var yamlLines = fileContent.Split('\n');
					var yamlWithoutComments = string.Join('\n', yamlLines.Where(line => !line.TrimStart().StartsWith('#')));
					var normalizedYaml = VersionToTargetRegex().Replace(yamlWithoutComments, "$1target:");

					entryData = deserializer.Deserialize<ChangelogData>(normalizedYaml);
				}
				catch (YamlException e)
				{
					this.EmitWarning($"Failed to parse changelog file '{entry.File.Name}': {e.Message}");
					continue;
				}
			}

			if (entryData != null)
				entries.Add(entryData);
		}

		return entries;
	}

	private IEnumerable<string> ComputeGeneratedAnchors()
	{
		foreach (var bundle in LoadedBundles)
		{
			var titleSlug = ChangelogTextUtilities.TitleToSlug(bundle.Version);
			var repo = bundle.Repo;

			// Group entries by type to determine which sections will exist
			var entriesByType = bundle.Entries
				.GroupBy(e => e.Type)
				.ToDictionary(g => g.Key, g => g.Count());

			// Features and enhancements section
			if (entriesByType.ContainsKey(ChangelogEntryType.Feature) ||
				entriesByType.ContainsKey(ChangelogEntryType.Enhancement))
				yield return $"{repo}-{titleSlug}-features-enhancements";

			// Fixes section
			if (entriesByType.ContainsKey(ChangelogEntryType.Security) ||
				entriesByType.ContainsKey(ChangelogEntryType.BugFix))
				yield return $"{repo}-{titleSlug}-fixes";

			// Documentation section
			if (entriesByType.ContainsKey(ChangelogEntryType.Docs))
				yield return $"{repo}-{titleSlug}-docs";

			// Regressions section
			if (entriesByType.ContainsKey(ChangelogEntryType.Regression))
				yield return $"{repo}-{titleSlug}-regressions";

			// Other changes section
			if (entriesByType.ContainsKey(ChangelogEntryType.Other))
				yield return $"{repo}-{titleSlug}-other";

			// Breaking changes section
			if (entriesByType.ContainsKey(ChangelogEntryType.BreakingChange))
				yield return $"{repo}-{titleSlug}-breaking-changes";

			// Deprecations section
			if (entriesByType.ContainsKey(ChangelogEntryType.Deprecation))
				yield return $"{repo}-{titleSlug}-deprecations";

			// Known issues section
			if (entriesByType.ContainsKey(ChangelogEntryType.KnownIssue))
				yield return $"{repo}-{titleSlug}-known-issues";
		}
	}
}
