@using Elastic.ApiExplorer.Landing
@using Elastic.ApiExplorer.Schemas
@using Microsoft.OpenApi
@inherits RazorSliceHttpResult<Elastic.ApiExplorer.Schemas.SchemaViewModel>
@implements IUsesLayout<Elastic.ApiExplorer._Layout, ApiLayoutViewModel>
@functions {
	public ApiLayoutViewModel LayoutModel => Model.CreateGlobalLayoutModel();

	private const int MaxDepth = 4;

	// Types that are known to be value types (resolve to primitives like string)
	private static readonly HashSet<string> KnownValueTypes = new(StringComparer.OrdinalIgnoreCase)
	{
		"Field", "Fields", "Id", "Ids", "IndexName", "Indices", "Name", "Names",
		"Routing", "VersionNumber", "SequenceNumber", "PropertyName", "RelationName",
		"TaskId", "ScrollId", "SuggestionName", "Duration", "DateMath", "Fuzziness",
		"GeoHashPrecision", "Distance", "TimeOfDay", "MinimumShouldMatch", "Script",
		"ByteSize", "Percentage", "Stringifiedboolean", "ExpandWildcards", "float", "Stringifiedinteger",
		// Numeric value types
		"uint", "ulong", "long", "int", "short", "ushort", "byte", "sbyte", "double", "decimal"
	};

	// Types that have dedicated pages we can link to
	// Only container types get their own pages - individual queries/aggregations are rendered inline
	private static readonly HashSet<string> LinkedTypes = new(StringComparer.OrdinalIgnoreCase)
	{
		"QueryContainer", "AggregationContainer", "Aggregate"
	};

	private static string GetContainerPageUrl(string typeName)
	{
		// Only container types get their own pages
		return typeName switch
		{
			"QueryContainer" => "/api/elasticsearch/types/_types-query_dsl-querycontainer",
			"AggregationContainer" => "/api/elasticsearch/types/_types-aggregations-aggregationcontainer",
			"Aggregate" => "/api/elasticsearch/types/_types-aggregations-aggregate",
			_ => null! // Should not be called for non-container types
		};
	}

	private static bool ShouldLinkToContainerPage(string typeName, string? currentPageType = null)
	{
		// Only actual container types have dedicated pages
		if (!LinkedTypes.Contains(typeName))
			return false;

		// Don't link to self when on a container page
		if (!string.IsNullOrEmpty(currentPageType) && typeName.Equals(currentPageType, StringComparison.OrdinalIgnoreCase))
			return false;

		return true;
	}

	/// <summary>
	/// Checks if a union option has properties, using fallback resolution if needed.
	/// Also recursively checks nested unions.
	/// </summary>
	private bool UnionOptionHasProperties((string Name, string? Ref, bool IsObject, IOpenApiSchema? Schema) option)
	{
		if (option.Schema == null) return false;

		// For non-object types, check if they're nested unions with object options
		if (!option.IsObject)
		{
			var nestedOptions = GetNestedUnionOptions(option.Schema);
			return nestedOptions.Any(UnionOptionHasProperties);
		}

		// Try to get properties directly first
		var props = GetSchemaProperties(option.Schema);
		if (props?.Count > 0) return true;

		// For schema references, try resolving via the Ref ID or the schema reference itself
		var refId = option.Ref;
		if (string.IsNullOrEmpty(refId) && option.Schema is OpenApiSchemaReference schemaRef)
			refId = schemaRef.Reference?.Id;

		if (!string.IsNullOrEmpty(refId) && Model.Document.Components?.Schemas?.TryGetValue(refId, out var resolvedSchema) == true)
		{
			props = GetSchemaProperties(resolvedSchema);
			if (props?.Count > 0) return true;

			// Try the original schema reference first (OpenApiSchemaReference proxies OneOf/AnyOf)
			var nestedOptions = GetNestedUnionOptions(option.Schema);
			if (nestedOptions.Count == 0)
			{
				// Fallback to resolved schema
				nestedOptions = GetNestedUnionOptions(resolvedSchema);
			}
			if (nestedOptions.Any(UnionOptionHasProperties)) return true;
		}

		// Try finding by name pattern
		if (Model.Document.Components?.Schemas != null)
		{
			var baseName = option.Name.EndsWith("[]") ? option.Name[..^2] : option.Name;
			var matchingSchema = Model.Document.Components.Schemas
				.FirstOrDefault(kvp => kvp.Key.EndsWith("." + baseName) || kvp.Key == baseName);
			if (matchingSchema.Value != null)
			{
				props = GetSchemaProperties(matchingSchema.Value);
				if (props?.Count > 0) return true;

				var nestedOptions = GetNestedUnionOptions(matchingSchema.Value);
				if (nestedOptions.Any(UnionOptionHasProperties)) return true;
			}
		}

		return false;
	}

	/// <summary>
	/// Resolves a schema reference to get the actual schema definition
	/// </summary>
	private IOpenApiSchema? ResolveSchemaRef(IOpenApiSchema? schema)
	{
		if (schema == null) return null;
		if (schema is OpenApiSchemaReference schemaRef)
		{
			var refId = schemaRef.Reference?.Id;
			if (!string.IsNullOrEmpty(refId) && Model.Document.Components?.Schemas?.TryGetValue(refId, out var resolved) == true)
			{
				return resolved;
			}
		}
		return schema;
	}

	/// <summary>
	/// Gets the union options from a schema's oneOf/anyOf, if present
	/// </summary>
	private List<(string Name, string? Ref, bool IsObject, IOpenApiSchema? Schema)> GetNestedUnionOptions(IOpenApiSchema? schema)
	{
		var result = new List<(string Name, string? Ref, bool IsObject, IOpenApiSchema? Schema)>();
		if (schema == null) return result;

		// Try multiple approaches to get union schemas:
		// 1. Check the original schema's OneOf/AnyOf
		// 2. If it's a reference, resolve and check the target
		IList<IOpenApiSchema>? unionSchemas = null;

		// First try the schema directly
		if (schema.OneOf is { Count: > 0 })
			unionSchemas = schema.OneOf;
		else if (schema.AnyOf is { Count: > 0 })
			unionSchemas = schema.AnyOf;

		// If not found and it's a reference, resolve and try again
		if (unionSchemas == null && schema is OpenApiSchemaReference schemaRef)
		{
			var refId = schemaRef.Reference?.Id;
			if (!string.IsNullOrEmpty(refId) && Model.Document.Components?.Schemas?.TryGetValue(refId, out var resolved) == true)
			{
				if (resolved.OneOf is { Count: > 0 })
					unionSchemas = resolved.OneOf;
				else if (resolved.AnyOf is { Count: > 0 })
					unionSchemas = resolved.AnyOf;
			}
		}

		if (unionSchemas == null) return result;

		foreach (var s in unionSchemas)
		{
			if (s is OpenApiSchemaReference unionRef)
			{
				var typeName = FormatSchemaName(unionRef.Reference?.Id ?? "unknown");
				result.Add((typeName, unionRef.Reference?.Id, !IsValueType(typeName), s));
			}
			else if (s?.Type?.HasFlag(JsonSchemaType.Array) == true && s.Items != null)
			{
				var itemInfo = GetTypeInfo(s.Items);
				result.Add(($"{itemInfo.TypeName}[]", itemInfo.SchemaRef, itemInfo.IsObject, s));
			}
			else if (s != null)
			{
				// Could be an inline schema or wrapped reference - try to get type info
				var info = GetTypeInfo(s);
				if (!string.IsNullOrEmpty(info.SchemaRef))
				{
					result.Add((info.TypeName, info.SchemaRef, info.IsObject, s));
				}
				else
				{
					var primName = GetPrimitiveTypeName(s.Type) ?? "unknown";
					result.Add((primName, null, false, s));
				}
			}
		}

		return result;
	}

	/// <summary>
	/// Flattens nested unions to get all leaf options (options with direct properties)
	/// </summary>
	private List<(string Name, string? Ref, bool IsObject, IOpenApiSchema? Schema)> FlattenUnionOptions(
		List<(string Name, string? Ref, bool IsObject, IOpenApiSchema? Schema)> options)
	{
		var result = new List<(string Name, string? Ref, bool IsObject, IOpenApiSchema? Schema)>();

		foreach (var option in options)
		{
			if (option.Schema == null) continue;

			var baseName = option.Name.EndsWith("[]") ? option.Name[..^2] : option.Name;
			var isArray = option.Name.EndsWith("[]");

			// For array types, we need to look at the Items schema
			IOpenApiSchema? schemaToCheck = option.Schema;
			if (option.Schema.Type?.HasFlag(JsonSchemaType.Array) == true && option.Schema.Items != null)
			{
				schemaToCheck = option.Schema.Items;
			}

			var hasDirectProps = false;
			IOpenApiSchema? resolvedSchema = schemaToCheck;

			var props = GetSchemaProperties(schemaToCheck);
			if (props?.Count > 0)
			{
				hasDirectProps = true;
			}
			else if (schemaToCheck is OpenApiSchemaReference schemaRef)
			{
				var refId = schemaRef.Reference?.Id;
				if (!string.IsNullOrEmpty(refId) && Model.Document.Components?.Schemas?.TryGetValue(refId, out var resolved) == true)
				{
					resolvedSchema = resolved;
					props = GetSchemaProperties(resolved);
					if (props?.Count > 0) hasDirectProps = true;
				}
			}

			if (!hasDirectProps && Model.Document.Components?.Schemas != null)
			{
				var matchingSchema = Model.Document.Components.Schemas
					.FirstOrDefault(kvp => kvp.Key.EndsWith("." + baseName) || kvp.Key == baseName);
				if (matchingSchema.Value != null)
				{
					resolvedSchema = matchingSchema.Value;
					props = GetSchemaProperties(matchingSchema.Value);
					if (props?.Count > 0) hasDirectProps = true;
				}
			}

			if (hasDirectProps)
			{
				// For arrays, keep the original name but use the resolved schema
				result.Add((option.Name, option.Ref, option.IsObject, resolvedSchema));
			}
			else if (resolvedSchema != null)
			{
				// Try the original schema first (OpenApiSchemaReference proxies OneOf/AnyOf correctly)
				var nestedOptions = GetNestedUnionOptions(schemaToCheck);
				if (nestedOptions.Count == 0)
				{
					// Fallback to resolved schema
					nestedOptions = GetNestedUnionOptions(resolvedSchema);
				}
				if (nestedOptions.Count > 0)
				{
					var flattenedNested = FlattenUnionOptions(nestedOptions);
					foreach (var nested in flattenedNested)
					{
						var nestedName = nested.Name;
						if (isArray && !nestedName.EndsWith("[]"))
							nestedName = $"{nestedName}[]";
						result.Add((nestedName, nested.Ref, nested.IsObject, nested.Schema));
					}
				}
			}
		}

		return result;
	}

	public string GetPrimitiveTypeName(JsonSchemaType? type)
	{
		if (type is null)
			return "";

		var typeName = "";
		if (type.Value.HasFlag(JsonSchemaType.Boolean))
			typeName = "boolean";
		else if (type.Value.HasFlag(JsonSchemaType.Integer))
			typeName = "integer";
		else if (type.Value.HasFlag(JsonSchemaType.String))
			typeName = "string";
		else if (type.Value.HasFlag(JsonSchemaType.Number))
			typeName = "number";
		else if (type.Value.HasFlag(JsonSchemaType.Null))
			typeName = "null";
		else if (type.Value.HasFlag(JsonSchemaType.Object))
			typeName = "object";

		return typeName;
	}

	public string FormatSchemaName(string schemaId)
	{
		var parts = schemaId.Split('.');
		return parts.Length > 0 ? parts[^1] : schemaId;
	}

	public bool IsValueType(string typeName) => KnownValueTypes.Contains(typeName);

	// Current page type is set from the model to prevent self-linking
	private string? _currentPageType;
	public bool IsLinkedType(string typeName) => ShouldLinkToContainerPage(typeName, _currentPageType);

	public string? GetValueTypeBase(IOpenApiSchema? schema)
	{
		if (schema is null) return null;
		var primitiveType = GetPrimitiveTypeName(schema.Type);
		if (!string.IsNullOrEmpty(primitiveType) && primitiveType != "object")
			return primitiveType;
		return null;
	}

	public record TypeInfo(
		string TypeName,
		string? SchemaRef,
		bool IsArray,
		bool IsObject,
		bool IsValueType,
		string? ValueTypeBase,
		bool HasLink,
		List<(string Name, string? Ref, bool IsObject, IOpenApiSchema? Schema)>? UnionOptions,
		bool IsDictionary = false,
		IOpenApiSchema? DictValueSchema = null,
		bool IsUnion = false
	);

	public TypeInfo GetTypeInfo(IOpenApiSchema? schema)
	{
		if (schema is null)
			return new TypeInfo("unknown", null, false, false, false, null, false, null);

		if (schema is OpenApiSchemaReference schemaRef)
		{
			var refId = schemaRef.Reference?.Id;
			if (!string.IsNullOrEmpty(refId))
			{
				var typeName = FormatSchemaName(refId);
				var isArray = schema.Type?.HasFlag(JsonSchemaType.Array) ?? false;
				var isValueType = IsValueType(typeName);
				var valueTypeBase = isValueType ? GetValueTypeBase(schemaRef) ?? "string" : null;
				var hasLink = IsLinkedType(typeName);

				// Check if the schema reference is a union (oneOf/anyOf)
				var isUnion = schemaRef.OneOf is { Count: > 0 } || schemaRef.AnyOf is { Count: > 0 };
				List<(string Name, string? Ref, bool IsObject, IOpenApiSchema? Schema)>? unionOptions = null;
				if (isUnion)
				{
					var unionSchemas = schemaRef.OneOf is { Count: > 0 } ? schemaRef.OneOf : schemaRef.AnyOf;
					var anyOfList = new List<(string Name, string? Ref, bool IsObject, IOpenApiSchema? Schema)>();
					foreach (var s in unionSchemas ?? [])
					{
						if (s is OpenApiSchemaReference unionRef)
						{
							var unionTypeName = FormatSchemaName(unionRef.Reference?.Id ?? "unknown");
							anyOfList.Add((unionTypeName, unionRef.Reference?.Id, !IsValueType(unionTypeName), s));
						}
						else if (s?.Type?.HasFlag(JsonSchemaType.Array) == true && s.Items != null)
						{
							// Array type - get the item type and add [] suffix
							var itemInfo = GetTypeInfo(s.Items);
							var arrayTypeName = $"{itemInfo.TypeName}[]";
							// Arrays of objects are expandable
							anyOfList.Add((arrayTypeName, itemInfo.SchemaRef, itemInfo.IsObject, s));
						}
						else
						{
							var primName = GetPrimitiveTypeName(s?.Type) ?? "unknown";
							anyOfList.Add((primName, null, false, s));
						}
					}
					unionOptions = anyOfList.Count > 0 ? anyOfList : null;
				}

				return new TypeInfo(typeName, refId, isArray, !isValueType, isValueType, valueTypeBase, hasLink, unionOptions, IsUnion: isUnion);
			}
		}

		if (schema.OneOf is { Count: > 0 } oneOf)
		{
			var options = oneOf.Where(s => s is not null).Select(s => {
				var info = GetTypeInfo(s);
				// Include [] suffix for array types
				var displayName = info.IsArray ? $"{info.TypeName}[]" : info.TypeName;
				return (Name: displayName, Ref: info.SchemaRef, IsObject: info.IsObject, Schema: (IOpenApiSchema?)s);
			}).ToList();

			var hasObjectOptions = options.Any(o => o.IsObject);
			if (hasObjectOptions && options.Count > 1)
				return new TypeInfo("oneOf", null, false, true, false, null, false, options, IsUnion: true);

			var typeNames = options.Select(o => o.Name).Distinct().ToArray();
			return new TypeInfo(string.Join(" | ", typeNames), null, false, false, false, null, false, options, IsUnion: true);
		}

		if (schema.AnyOf is { Count: > 0 } anyOf)
		{
			var options = anyOf.Where(s => s is not null).Select(s => {
				var info = GetTypeInfo(s);
				// Include [] suffix for array types
				var displayName = info.IsArray ? $"{info.TypeName}[]" : info.TypeName;
				return (Name: displayName, Ref: info.SchemaRef, IsObject: info.IsObject, Schema: (IOpenApiSchema?)s);
			}).ToList();

			var hasObjectOptions = options.Any(o => o.IsObject);
			if (hasObjectOptions && options.Count > 1)
				return new TypeInfo("anyOf", null, false, true, false, null, false, options, IsUnion: true);

			var typeNames = options.Select(o => o.Name).Distinct().ToArray();
			return new TypeInfo(string.Join(" | ", typeNames), null, false, false, false, null, false, options, IsUnion: true);
		}

		if (schema.AllOf is { Count: > 0 } allOf)
		{
			var refSchemas = allOf.OfType<OpenApiSchemaReference>().ToArray();
			if (refSchemas.Length > 0)
			{
				var refId = refSchemas[0].Reference?.Id;
				if (!string.IsNullOrEmpty(refId))
				{
					var typeName = FormatSchemaName(refId);
					var isValueType = IsValueType(typeName);
					var hasLink = IsLinkedType(typeName);
					return new TypeInfo(typeName, refId, false, !isValueType, isValueType, null, hasLink, null);
				}
			}
		}

		if (schema.Type?.HasFlag(JsonSchemaType.Array) ?? false)
		{
			if (schema.Items is not null)
			{
				var itemInfo = GetTypeInfo(schema.Items);
				return new TypeInfo(itemInfo.TypeName, itemInfo.SchemaRef, true, itemInfo.IsObject, itemInfo.IsValueType, itemInfo.ValueTypeBase, itemInfo.HasLink, null);
			}
			return new TypeInfo("unknown", null, true, false, false, null, false, null);
		}

		if (schema.Enum is { Count: > 0 })
			return new TypeInfo("enum", null, false, false, false, null, false, null);

		if (schema.AdditionalProperties is IOpenApiSchema addProps)
		{
			var valueInfo = GetTypeInfo(addProps);
			// Check if the dictionary value type is a reference that points to a union type
			var resolvedValueSchema = addProps;
			List<(string Name, string? Ref, bool IsObject, IOpenApiSchema? Schema)>? unionOptions = null;
			var isUnion = false;

			if (addProps is OpenApiSchemaReference addPropsRef)
			{
				var addPropsRefId = addPropsRef.Reference?.Id;
				if (!string.IsNullOrEmpty(addPropsRefId) && Model.Document.Components?.Schemas?.TryGetValue(addPropsRefId, out var resolvedAddPropsSchema) == true)
				{
					resolvedValueSchema = resolvedAddPropsSchema;
					// Check if the resolved schema is a union type
					if (resolvedAddPropsSchema.OneOf is { Count: > 0 } dictOneOf)
					{
						unionOptions = dictOneOf.Where(s => s is not null).Select(s => {
							var info = GetTypeInfo(s);
							return (Name: info.TypeName, Ref: info.SchemaRef, IsObject: info.IsObject, Schema: (IOpenApiSchema?)s);
						}).ToList();
						isUnion = unionOptions.Any(o => o.IsObject);
					}
					else if (resolvedAddPropsSchema.AnyOf is { Count: > 0 } dictAnyOf)
					{
						unionOptions = dictAnyOf.Where(s => s is not null).Select(s => {
							var info = GetTypeInfo(s);
							return (Name: info.TypeName, Ref: info.SchemaRef, IsObject: info.IsObject, Schema: (IOpenApiSchema?)s);
						}).ToList();
						isUnion = unionOptions.Any(o => o.IsObject);
					}
				}
			}

			// Pass valueInfo.HasLink so we know if the dictionary value type has a dedicated page
			return new TypeInfo($"string to {valueInfo.TypeName}", valueInfo.SchemaRef, false, true, false, null, valueInfo.HasLink, unionOptions, true, resolvedValueSchema, isUnion);
		}

		if (schema.Properties is { Count: > 0 })
			return new TypeInfo("object", null, false, true, false, null, false, null);

		var primitiveName = GetPrimitiveTypeName(schema.Type);
		if (!string.IsNullOrEmpty(primitiveName))
			return new TypeInfo(primitiveName, null, false, primitiveName == "object", false, null, false, null);

		return new TypeInfo("object", null, false, true, false, null, false, null);
	}

	public IDictionary<string, IOpenApiSchema>? GetSchemaProperties(IOpenApiSchema? schema)
	{
		if (schema is null) return null;

		// Handle schema references - resolve to get actual properties
		if (schema is OpenApiSchemaReference schemaRef)
		{
			// OpenApiSchemaReference proxies to the target schema
			// Try direct property access first (proxied)
			if (schemaRef.Properties is { Count: > 0 })
				return schemaRef.Properties;

			// Try resolving via Reference.Id
			var refId = schemaRef.Reference?.Id;
			if (!string.IsNullOrEmpty(refId))
			{
				// Try to get the resolved schema from the document
				if (Model.Document.Components?.Schemas?.TryGetValue(refId, out var resolvedSchema) == true)
				{
					return GetSchemaProperties(resolvedSchema);
				}
			}
			// Fall through to try other schema properties
		}

		if (schema.Properties is { Count: > 0 })
			return schema.Properties;

		if (schema.AllOf is { Count: > 0 } allOf)
		{
			var props = new Dictionary<string, IOpenApiSchema>();
			foreach (var subSchema in allOf)
			{
				var subProps = GetSchemaProperties(subSchema);
				if (subProps is not null)
				{
					foreach (var prop in subProps)
						props.TryAdd(prop.Key, prop.Value);
				}
			}
			return props.Count > 0 ? props : null;
		}

		return null;
	}

	public IHtmlContent RenderSchemaType(IOpenApiSchema schema, HashSet<string>? ancestorTypes = null)
	{
		var info = GetTypeInfo(schema);
		var sb = new System.Text.StringBuilder();

		// Build the display text with [] for arrays and {} for objects
		if (info.IsArray)
		{
			sb.Append("<span class=\"array-icon\">[] </span>");
			if (info.IsValueType && info.ValueTypeBase != null)
			{
				sb.Append($"{info.ValueTypeBase} ");
			}
			else if (info.IsObject && !string.IsNullOrEmpty(info.SchemaRef))
			{
				sb.Append("<span class=\"object-icon\">{} </span>");
			}
		}
		else if (info.IsDictionary)
		{
			// Dictionary uses a map icon and {} for object value types
			sb.Append("<span class=\"dict-icon\">(map) </span>");
			if (info.HasLink || (info.DictValueSchema != null && GetTypeInfo(info.DictValueSchema).IsObject))
			{
				sb.Append("<span class=\"object-icon\">{} </span>");
			}
		}
		else if (info.IsUnion && info.UnionOptions != null)
		{
			// Union types get a special icon
			sb.Append("<span class=\"union-icon\">| </span>");
		}
		else if (info.IsValueType && info.ValueTypeBase != null)
		{
			sb.Append($"{info.ValueTypeBase} ");
		}
		else if (info.IsObject && !string.IsNullOrEmpty(info.SchemaRef) && !info.HasLink)
		{
			// Regular objects get {} (but not linked types - they get it below)
			sb.Append("<span class=\"object-icon\">{} </span>");
		}

		var displayName = System.Web.HttpUtility.HtmlEncode(info.TypeName);
		var titleAttr = !string.IsNullOrEmpty(info.SchemaRef) ? $" title=\"{info.SchemaRef}\"" : "";

		// Add {} prefix for linked types (they have dedicated pages)
		if (info.HasLink && !info.IsDictionary)
		{
			sb.Append("<span class=\"object-icon\">{} </span>");
		}

		sb.Append($"<span{titleAttr}>{displayName}</span>");

		return new HtmlString($"<code class=\"schema-type\">{sb}</code>");
	}

	public IHtmlContent RenderRecursiveBadge()
	{
		return new HtmlString("<span class=\"recursive\">recursive</span>");
	}

	public IHtmlContent RenderUnionOptions(List<(string Name, string? Ref, bool IsObject, IOpenApiSchema? Schema)> options, string prefix, int depth, HashSet<string>? ancestorTypes = null)
	{
		if (options.Count == 0)
			return HtmlString.Empty;

		// Show "One of:" with sorted options (X[] before X, deduplicated)
		var sortedOptionNames = options.Select(o => o.Name)
			.OrderByDescending(o => o.EndsWith("[]"))
			.Distinct()
			.ToArray();

		<div class="union-options">
			<span class="values-label">One of:</span>
			@foreach (var optName in sortedOptionNames)
			{
				<span class="union-option">@optName</span>
			}
		</div>

		// Flatten nested unions to get leaf object types
		var flattenedOptions = FlattenUnionOptions(options);

		// Filter to only object options that have properties we can expand
		var objectOptions = flattenedOptions.Where(o => o.IsObject && o.Schema != null).ToList();

		// If no object options with properties, we're done (already showed the options list)
		if (objectOptions.Count == 0)
		{
			return HtmlString.Empty;
		}

		// Consolidate X and X[] variants - only show properties once, with X[] listed first
		var consolidatedOptions = objectOptions
			.GroupBy(o => o.Name.EndsWith("[]") ? o.Name[..^2] : o.Name)
			.Select(g => {
				var hasArray = g.Any(o => o.Name.EndsWith("[]"));
				var baseOption = g.FirstOrDefault(o => !o.Name.EndsWith("[]"));
				var arrayOption = g.FirstOrDefault(o => o.Name.EndsWith("[]"));
				var displayOption = baseOption.Schema != null ? baseOption : arrayOption;
				var displayNames = hasArray && baseOption.Schema != null
					? new[] { $"{g.Key}[]", g.Key }
					: new[] { g.First().Name };
				return (Names: displayNames, Option: displayOption);
			})
			.Where(x => x.Option.Schema != null)
			.ToList();

		// Show expandable union variants
		<div class="union-variants">
			<dl class="property-list">
				@foreach (var consolidated in consolidatedOptions)
				{
					var option = consolidated.Option;
					var displayNames = consolidated.Names;
					if (option.Schema is null) continue;

					// Get base name for schema lookup
					var baseName = option.Name.EndsWith("[]") ? option.Name[..^2] : option.Name;

					// Get properties - try direct first, then resolve via Ref or schema reference
					var optionProps = GetSchemaProperties(option.Schema);
					IOpenApiSchema schemaToRender = option.Schema;
					if (optionProps is null || optionProps.Count == 0)
					{
						var refId = option.Ref;
						if (string.IsNullOrEmpty(refId) && option.Schema is OpenApiSchemaReference schemaRef)
							refId = schemaRef.Reference?.Id;

						if (!string.IsNullOrEmpty(refId) && Model.Document.Components?.Schemas?.TryGetValue(refId, out var resolvedSchema) == true)
						{
							optionProps = GetSchemaProperties(resolvedSchema);
							schemaToRender = resolvedSchema;
						}
						else if (Model.Document.Components?.Schemas != null)
						{
							// Try finding by name pattern
							var matchingSchema = Model.Document.Components.Schemas
								.FirstOrDefault(kvp => kvp.Key.EndsWith("." + baseName) || kvp.Key == baseName);
							if (matchingSchema.Value != null)
							{
								optionProps = GetSchemaProperties(matchingSchema.Value);
								schemaToRender = matchingSchema.Value;
							}
						}
					}
					if (optionProps is null || optionProps.Count == 0) continue;

					var optionId = $"{prefix}-variant-{baseName.ToLowerInvariant().Replace(" ", "-")}";
					var nestedPropCount = optionProps.Count;
					var isCollapsible = nestedPropCount > 2;
					var defaultExpanded = depth == 0 ? false : (nestedPropCount > 0 && nestedPropCount < 5);

					// Build ancestor set including current variant type
					var newAncestors = ancestorTypes != null ? new HashSet<string>(ancestorTypes) : new HashSet<string>();
					if (!string.IsNullOrEmpty(baseName))
						newAncestors.Add(baseName);

					<div class="property-item union-variant depth-@depth has-children @(isCollapsible ? (defaultExpanded ? "expanded" : "collapsed") : "")">
						<dt id="@optionId">
							<span class="union-variant-label">
								<span class="object-icon">{} </span>
								@foreach (var name in displayNames)
								{
									<code>@name</code>
								}
							</span>
						</dt>
						@if (!string.IsNullOrEmpty(schemaToRender.Description))
						{
							<dd class="variant-description">
								@Model.RenderMarkdown(schemaToRender.Description)
							</dd>
						}
						@if (isCollapsible)
						{
							<dd class="expand-toggle-row">
								<button class="expand-toggle" aria-expanded="@(defaultExpanded ? "true" : "false")" aria-controls="@optionId-children" title="@(defaultExpanded ? "Collapse" : "Expand") @nestedPropCount properties">
									<span class="toggle-icon">@(defaultExpanded ? "−" : "+")</span>
									<span class="toggle-label">@(defaultExpanded ? "Hide" : "Show") @nestedPropCount properties</span>
								</button>
							</dd>
						}
						<div class="nested-properties" id="@optionId-children">
							@RenderProperties(schemaToRender, optionId, depth + 1, newAncestors)
						</div>
					</div>
				}
			</dl>
		</div>

		return HtmlString.Empty;
	}

	public IHtmlContent RenderProperties(IOpenApiSchema? schema, string prefix, int depth, HashSet<string>? ancestorTypes = null)
	{
		var properties = GetSchemaProperties(schema);
		if (properties is null || properties.Count == 0)
			return HtmlString.Empty;

		var requiredProps = schema?.Required ?? new HashSet<string>();
		var propArray = properties.ToArray();

		<dl class="property-list">
			@for (var i = 0; i < propArray.Length; i++)
			{
				var property = propArray[i];
				var propSchema = property.Value;
				if (propSchema is null) continue;
				var isRequired = requiredProps.Contains(property.Key);
				var typeInfo = GetTypeInfo(propSchema);
				var propId = string.IsNullOrEmpty(prefix) ? property.Key : $"{prefix}-{property.Key}";
				var isLast = i == propArray.Length - 1;
				var hasDescription = !string.IsNullOrWhiteSpace(propSchema.Description);

				// Check if this type appears in any ancestor (recursive detection)
				var isRecursive = ancestorTypes != null && !string.IsNullOrEmpty(typeInfo.TypeName) && ancestorTypes.Contains(typeInfo.TypeName);

				// Also check dictionary value types for recursion (e.g., "aggregations" map string to AggregationContainer)
				if (!isRecursive && typeInfo.IsDictionary && typeInfo.DictValueSchema != null)
				{
					var dictValueType = GetTypeInfo(typeInfo.DictValueSchema);
					isRecursive = ancestorTypes != null && !string.IsNullOrEmpty(dictValueType.TypeName) && ancestorTypes.Contains(dictValueType.TypeName);
				}

				// For dictionaries with linked value types, typeInfo.HasLink is true
				var dictHasLinkedValue = typeInfo.IsDictionary && typeInfo.HasLink;

				// Determine if we should show nested properties
				// Don't expand if the type has a dedicated page (linked type)
				var hasNestedProps = typeInfo.IsObject && !typeInfo.HasLink && depth < MaxDepth && GetSchemaProperties(propSchema)?.Count > 0;

				// For dictionaries, check if the value type has properties we should show
				// Don't expand if the value type has a dedicated page (linked type)
				var hasDictValueProps = typeInfo.IsDictionary && typeInfo.DictValueSchema != null
					&& depth < MaxDepth && !dictHasLinkedValue && GetSchemaProperties(typeInfo.DictValueSchema)?.Count > 0;

				// For arrays, check if the item type has properties we should show
				var arrayItemSchema = typeInfo.IsArray && propSchema.Items != null ? propSchema.Items : null;
				var hasArrayItemProps = arrayItemSchema != null && !typeInfo.HasLink && depth < MaxDepth
					&& GetSchemaProperties(arrayItemSchema)?.Count > 0;

				// For union types, check if there are object options with properties (using helper with fallback resolution)
				// First, detect "simple" X | X[] unions - same base type, just one single and one array variant
				var isSimpleArrayUnion = false;
				string? simpleUnionBaseName = null;
				if (typeInfo.IsUnion && typeInfo.UnionOptions != null && typeInfo.UnionOptions.Count > 0)
				{
					var unionOptionNames = typeInfo.UnionOptions.Select(o => o.Name).Distinct().ToArray();

					// Check if this is exactly X and X[] (same base type)
					if (unionOptionNames.Length == 2)
					{
						var baseNames = unionOptionNames.Select(n => n.EndsWith("[]") ? n[..^2] : n).Distinct().ToArray();
						if (baseNames.Length == 1 && !string.IsNullOrEmpty(baseNames[0]))
						{
							isSimpleArrayUnion = true;
							simpleUnionBaseName = baseNames[0];
						}
					}
				}

				// For simple X | X[] unions, don't expand tree - show inline instead
				var hasUnionOptions = typeInfo.IsUnion && typeInfo.UnionOptions != null && depth < MaxDepth
					&& !isSimpleArrayUnion
					&& typeInfo.UnionOptions.Any(UnionOptionHasProperties);

				// For simple unions, check if the base type has properties we should expand (when NOT linked)
				var simpleUnionHasExpandableProps = false;
				IOpenApiSchema? simpleUnionSchema = null;
				if (isSimpleArrayUnion && !string.IsNullOrEmpty(simpleUnionBaseName) && typeInfo.UnionOptions != null && depth < MaxDepth)
				{
					var baseOption = typeInfo.UnionOptions.FirstOrDefault(o => o.Name == simpleUnionBaseName);
					if (baseOption.Schema != null)
					{
						var baseTypeInfo = GetTypeInfo(baseOption.Schema);
						// Only expand if NOT linked (linked types have their own page)
						if (!baseTypeInfo.HasLink && UnionOptionHasProperties(baseOption))
						{
							simpleUnionHasExpandableProps = true;
							simpleUnionSchema = baseOption.Schema;
						}
					}
				}

				// Count nested properties
				var nestedPropCount = 0;
				if (hasNestedProps)
					nestedPropCount = GetSchemaProperties(propSchema)?.Count ?? 0;
				else if (hasDictValueProps && typeInfo.DictValueSchema != null)
					nestedPropCount = GetSchemaProperties(typeInfo.DictValueSchema)?.Count ?? 0;
				else if (hasArrayItemProps && arrayItemSchema != null)
					nestedPropCount = GetSchemaProperties(arrayItemSchema)?.Count ?? 0;
				else if (hasUnionOptions && typeInfo.UnionOptions != null)
					nestedPropCount = typeInfo.UnionOptions.Count(UnionOptionHasProperties);
				else if (simpleUnionHasExpandableProps && simpleUnionSchema != null)
					nestedPropCount = GetSchemaProperties(simpleUnionSchema)?.Count ?? 0;

				// Only show collapse toggle if more than 2 properties
				// Dictionary types have their toggle at the <string> key level, not the parent level
				// Simple unions with expandable props should have toggle
				var hasChildren = (hasNestedProps || hasDictValueProps || hasArrayItemProps || hasUnionOptions || simpleUnionHasExpandableProps) && !isRecursive;
				var isCollapsible = hasChildren && nestedPropCount > 2 && !hasDictValueProps;

				// On type pages: depth-0 properties default to collapsed, deeper levels expand if < 5 properties
				var defaultExpanded = depth == 0 ? false : (nestedPropCount > 0 && nestedPropCount < 5);

				<div class="property-item depth-@depth @(isLast ? "last-sibling" : "") @(hasChildren ? "has-children" : "") @(isCollapsible ? (defaultExpanded ? "expanded" : "collapsed") : "")">
					<dt id="@propId">
						<a href="#@propId">
							<code>@property.Key</code>
							@RenderSchemaType(propSchema, ancestorTypes)
							@if (!isRequired)
							{
								<span class="optional">optional</span>
							}
							@if (isRecursive)
							{
								@RenderRecursiveBadge()
							}
						</a>
					</dt>
					@if (hasDescription)
					{
						<dd>
							@Model.RenderMarkdown(propSchema.Description)
						</dd>
					}
					@if (isSimpleArrayUnion && !string.IsNullOrEmpty(simpleUnionBaseName))
					{
						// Simple X | X[] union - show horizontal layout
						var baseTypeOption = typeInfo.UnionOptions?.FirstOrDefault(o => o.Name == simpleUnionBaseName);
						var isObjectType = baseTypeOption?.IsObject ?? false;
						<dd class="union-inline-row">
							<span class="values-label">One of:</span>
							<span class="union-inline-options">
								<span class="union-inline-option">
									@if (isObjectType)
									{
										<span class="object-icon">{}</span>
									}
									<code class="schema-type"><span>@simpleUnionBaseName</span></code>
								</span>
								<span class="union-inline-separator">or</span>
								<span class="union-inline-option">
									<span class="array-icon">[]</span>
									@if (isObjectType)
									{
										<span class="object-icon">{}</span>
									}
									<code class="schema-type"><span>@(simpleUnionBaseName)[]</span></code>
								</span>
							</span>
						</dd>
					}
					@{
						// Add link to type page for linked types
						// For simple X | X[] unions, check if the base type has a linked page
						string? linkedTypeName = null;
						if (typeInfo.HasLink)
						{
							linkedTypeName = typeInfo.IsDictionary && typeInfo.DictValueSchema != null
								? GetTypeInfo(typeInfo.DictValueSchema).TypeName
								: typeInfo.TypeName;
						}
						else if (isSimpleArrayUnion && !string.IsNullOrEmpty(simpleUnionBaseName) && typeInfo.UnionOptions != null)
						{
							// Check if the base type in the simple union is a linked type
							var baseOption = typeInfo.UnionOptions.FirstOrDefault(o => o.Name == simpleUnionBaseName);
							if (baseOption.Schema != null)
							{
								var baseTypeInfo = GetTypeInfo(baseOption.Schema);
								if (baseTypeInfo.HasLink)
									linkedTypeName = simpleUnionBaseName;
							}
						}
					}
					@if (!string.IsNullOrEmpty(linkedTypeName))
					{
						var typePageUrl = GetContainerPageUrl(linkedTypeName);
						<dd class="type-link-description">
							<a href="@typePageUrl" data-hx-boost="false">See @linkedTypeName type →</a>
						</dd>
					}
					@if (isCollapsible)
					{
						<dd class="expand-toggle-row">
							<button class="expand-toggle" aria-expanded="@(defaultExpanded ? "true" : "false")" aria-controls="@propId-children" title="@(defaultExpanded ? "Collapse" : "Expand") @nestedPropCount properties">
								<span class="toggle-icon">@(defaultExpanded ? "−" : "+")</span>
								<span class="toggle-label">@(defaultExpanded ? "Hide" : "Show") @nestedPropCount properties</span>
							</button>
						</dd>
					}
					@if (!isRecursive)
					{
						// Build new ancestor set including current type
						var newAncestors = ancestorTypes != null ? new HashSet<string>(ancestorTypes) : new HashSet<string>();
						if (!string.IsNullOrEmpty(typeInfo.TypeName) && typeInfo.IsObject)
						{
							// For dictionaries, add the value type name rather than "string to X"
							if (typeInfo.IsDictionary && typeInfo.DictValueSchema != null)
							{
								var dictValueType = GetTypeInfo(typeInfo.DictValueSchema);
								if (!string.IsNullOrEmpty(dictValueType.TypeName))
									newAncestors.Add(dictValueType.TypeName);
							}
							else
							{
								newAncestors.Add(typeInfo.TypeName);
							}
						}

						if (typeInfo.IsDictionary && hasUnionOptions && typeInfo.UnionOptions != null)
						{
							// Dictionary with union value type - show key level, then union variants
							// Union options are always expanded (no toggle)
							var keyPropId = $"{propId}-string";
							<div class="nested-properties" id="@propId-children">
								<dl class="property-list">
									<div class="property-item depth-@(depth + 1) last-sibling has-children expanded">
										<dt id="@keyPropId">
											<code>&lt;string&gt;</code>
											<code class="schema-type"><span class="union-icon">| </span>@GetTypeInfo(typeInfo.DictValueSchema).TypeName</code>
										</dt>
										<div class="nested-properties">
											@RenderUnionOptions(typeInfo.UnionOptions, keyPropId, depth + 2, newAncestors)
										</div>
									</div>
								</dl>
							</div>
						}
						else if (hasDictValueProps && typeInfo.DictValueSchema != null)
						{
							// Show dictionary with intermediary key level - key is always string for additionalProperties
							// The expand toggle appears at this <string> key level, not the parent property level
							var keyPropId = $"{propId}-string";
							var dictIsCollapsible = nestedPropCount > 2;
							var dictDefaultExpanded = depth == 0 ? false : (nestedPropCount > 0 && nestedPropCount < 5);
							<div class="nested-properties" id="@propId-children">
								<dl class="property-list">
									<div class="property-item depth-@(depth + 1) last-sibling has-children @(dictIsCollapsible ? (dictDefaultExpanded ? "expanded" : "collapsed") : "")">
										<dt id="@keyPropId">
											<code>&lt;string&gt;</code>
											@RenderSchemaType(typeInfo.DictValueSchema, newAncestors)
										</dt>
										@if (dictIsCollapsible)
										{
											<dd class="expand-toggle-row">
												<button class="expand-toggle" aria-expanded="@(dictDefaultExpanded ? "true" : "false")" aria-controls="@keyPropId-children" title="@(dictDefaultExpanded ? "Collapse" : "Expand") @nestedPropCount properties">
													<span class="toggle-icon">@(dictDefaultExpanded ? "−" : "+")</span>
													<span class="toggle-label">@(dictDefaultExpanded ? "Hide" : "Show") @nestedPropCount properties</span>
												</button>
											</dd>
										}
										<div class="nested-properties" id="@keyPropId-children">
											@RenderProperties(typeInfo.DictValueSchema, keyPropId, depth + 2, newAncestors)
										</div>
									</div>
								</dl>
							</div>
						}
						else if (hasNestedProps)
						{
							<div class="nested-properties" id="@propId-children">
								@RenderProperties(propSchema, propId, depth + 1, newAncestors)
							</div>
						}
						else if (hasArrayItemProps && arrayItemSchema != null)
						{
							// Show array item properties
							<div class="nested-properties" id="@propId-children">
								@RenderProperties(arrayItemSchema, propId, depth + 1, newAncestors)
							</div>
						}
						else if (hasUnionOptions && typeInfo.UnionOptions != null)
						{
							// Show union variant options
							<div class="nested-properties" id="@propId-children">
								@RenderUnionOptions(typeInfo.UnionOptions, propId, depth + 1, newAncestors)
							</div>
						}
						else if (simpleUnionHasExpandableProps && simpleUnionSchema != null)
						{
							// Show properties for simple X | X[] union (non-linked type)
							<div class="nested-properties" id="@propId-children">
								@RenderProperties(simpleUnionSchema, propId, depth + 1, newAncestors)
							</div>
						}
					}
				</div>
			}
		</dl>

		return HtmlString.Empty;
	}
}
@{
	var schema = Model.Schema;
	var openApiSchema = schema.Schema;
	var isAggregation = schema.Category == "aggregations";

	// Set the current page type for self-link prevention
	_currentPageType = schema.DisplayName;

	// Check if this is a container type that represents a dictionary
	var isContainerType = schema.DisplayName is "QueryContainer" or "AggregationContainer" or "Aggregate";
	var dictionaryTypeName = schema.DisplayName switch
	{
		"AggregationContainer" => "Dictionary<string, AggregationContainer>",
		"Aggregate" => "Dictionary<string, Aggregate>",
		_ => null
	};

	// Initialize ancestor set with the root type name to detect recursive references
	var rootAncestors = new HashSet<string> { schema.DisplayName };

	// Determine which sections exist
	var hasDescription = !string.IsNullOrEmpty(openApiSchema.Description);
	var hasEnum = openApiSchema.Enum is { Count: > 0 };
	var hasOneOf = openApiSchema.OneOf is { Count: > 0 };
	var hasAnyOf = openApiSchema.AnyOf is { Count: > 0 };
	var hasAggRequest = isAggregation && schema.RelatedAggregation is not null;
	var hasProperties = !hasAggRequest && GetSchemaProperties(openApiSchema) is { Count: > 0 };
	var hasAggResponse = isAggregation && schema.RelatedAggregate is not null;
	var hasAdditionalProps = openApiSchema.AdditionalProperties is IOpenApiSchema;
	var hasExample = openApiSchema.Example is not null;
}

<section id="schema-definition">
	<h1>@schema.DisplayName</h1>
	<p class="schema-id"><code>@schema.SchemaId</code></p>

	@if (!string.IsNullOrEmpty(dictionaryTypeName))
	{
		<p class="schema-type-info">
			<span class="dict-icon">(map) </span>
			<code class="schema-type">@dictionaryTypeName</code>
		</p>
		<p>This type represents a dictionary mapping string keys to <code>@schema.DisplayName</code> values.</p>
	}

	@if (hasDescription)
	{
		<h3 class="section-header" id="description" data-section="description">
			<span>Description</span>
		</h3>
		<p>@Model.RenderMarkdown(openApiSchema.Description)</p>
	}

	@if (hasEnum)
	{
		<h3 class="section-header" id="enum-values" data-section="enum-values">
			<span>Enum Values</span>
		</h3>
		<ul class="enum-values">
			@foreach (var enumValue in openApiSchema.Enum!)
			{
				<li><code>@enumValue</code></li>
			}
		</ul>
	}

	@if (hasOneOf)
	{
		<h3 class="section-header" id="union-types" data-section="union-types">
			<span>Union Types (oneOf)</span>
		</h3>
		<p>This type can be one of the following:</p>
		<ul class="union-types">
			@foreach (var variant in openApiSchema.OneOf!)
			{
				if (variant is null) continue;
				<li>@RenderSchemaType(variant)</li>
			}
		</ul>
	}

	@if (hasAnyOf)
	{
		<h3 class="section-header" id="union-types" data-section="union-types">
			<span>Union Types (anyOf)</span>
		</h3>
		<p>This type can be any of the following:</p>
		<ul class="union-types">
			@foreach (var variant in openApiSchema.AnyOf!)
			{
				if (variant is null) continue;
				<li>@RenderSchemaType(variant)</li>
			}
		</ul>
	}

	@* For aggregations, show both aggregation request and aggregate response *@
	@if (hasAggRequest)
	{
		<h3 class="section-header" id="aggregation-request" data-section="aggregation-request">
			<span>Aggregation Request</span>
		</h3>
		<p>Properties for configuring the <code>@(schema.DisplayName)</code> aggregation:</p>
		@RenderProperties(schema.RelatedAggregation, "agg", 0, rootAncestors)
	}
	else if (hasProperties)
	{
		<h3 class="section-header" id="properties" data-section="properties">
			<span>Properties</span>
		</h3>
		@RenderProperties(openApiSchema, "", 0, rootAncestors)
	}

	@if (hasAggResponse)
	{
		<h3 class="section-header" id="aggregate-response" data-section="aggregate-response">
			<span>Aggregate Response</span>
		</h3>
		<p>Properties returned in the <code>@(schema.DisplayName)</code> aggregate response:</p>
		@RenderProperties(schema.RelatedAggregate, "result", 0, rootAncestors)
	}

	@if (hasAdditionalProps && openApiSchema.AdditionalProperties is IOpenApiSchema addPropsSchema)
	{
		<h3 class="section-header" id="additional-properties" data-section="additional-properties">
			<span>Additional Properties</span>
		</h3>
		<p>This type allows additional properties of type: @RenderSchemaType(addPropsSchema)</p>
	}

	@if (hasExample)
	{
		<h3 class="section-header" id="example" data-section="example">
			<span>Example</span>
		</h3>
		<pre><code class="language-json">@openApiSchema.Example</code></pre>
	}
</section>

<script>
(function() {
	// Use event delegation on the section
	const section = document.getElementById('schema-definition');
	if (!section) return;

	section.addEventListener('click', function(e) {
		// Handle expand/collapse toggle buttons
		const toggleBtn = e.target.closest('.expand-toggle');
		if (toggleBtn) {
			e.preventDefault();
			e.stopPropagation();

			const propertyItem = toggleBtn.closest('.property-item');
			if (!propertyItem) return;

			const isExpanded = propertyItem.classList.contains('expanded');
			const toggleIcon = toggleBtn.querySelector('.toggle-icon');
			const toggleLabel = toggleBtn.querySelector('.toggle-label');
			const propCount = toggleLabel?.textContent?.match(/\d+/)?.[0] || '';

			if (isExpanded) {
				propertyItem.classList.remove('expanded');
				propertyItem.classList.add('collapsed');
				toggleBtn.setAttribute('aria-expanded', 'false');
				if (toggleIcon) toggleIcon.textContent = '+';
				if (toggleLabel) toggleLabel.textContent = `Show ${propCount} properties`;
			} else {
				propertyItem.classList.remove('collapsed');
				propertyItem.classList.add('expanded');
				toggleBtn.setAttribute('aria-expanded', 'true');
				if (toggleIcon) toggleIcon.textContent = '−';
				if (toggleLabel) toggleLabel.textContent = `Hide ${propCount} properties`;
			}
		}
	});
})();
</script>
