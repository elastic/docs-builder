@using Elastic.ApiExplorer.Landing
@using Elastic.ApiExplorer.Operations
@using Elastic.ApiExplorer.Schema
@using Microsoft.OpenApi
@inherits RazorSliceHttpResult<Elastic.ApiExplorer.Operations.OperationViewModel>
@implements IUsesLayout<Elastic.ApiExplorer._Layout, ApiLayoutViewModel>
@functions {
	public ApiLayoutViewModel LayoutModel => Model.CreateGlobalLayoutModel();

	// Schema analyzer instance - created lazily
	private SchemaAnalyzer? _analyzer;
	private SchemaAnalyzer Analyzer => _analyzer ??= new SchemaAnalyzer(Model.Document);

	// Delegate to shared helpers
	private static string GetContainerPageUrl(string typeName) => SchemaHelpers.GetContainerPageUrl(typeName) ?? "";
	private static bool ShouldLinkToContainerPage(string typeName) => SchemaHelpers.ShouldLinkToContainerPage(typeName);

	// Delegate schema analysis to Analyzer
	private bool UnionOptionHasProperties(UnionOption option) => Analyzer.UnionOptionHasProperties(option);
	private List<UnionOption> GetNestedUnionOptions(IOpenApiSchema? schema) => Analyzer.GetNestedUnionOptions(schema);
	private List<UnionOption> FlattenUnionOptions(List<UnionOption> options) => Analyzer.FlattenUnionOptions(options);
	private IOpenApiSchema? ResolveSchema(IOpenApiSchema? schema) => Analyzer.ResolveSchema(schema);
	private IDictionary<string, IOpenApiSchema>? GetSchemaProperties(IOpenApiSchema? schema) => Analyzer.GetSchemaProperties(schema);
	private TypeInfo GetTypeInfo(IOpenApiSchema? schema) => Analyzer.GetTypeInfo(schema);

	// Delegate simple helpers to SchemaHelpers
	public string GetPrimitiveTypeName(JsonSchemaType? type) => SchemaHelpers.GetPrimitiveTypeName(type);
	public string FormatSchemaName(string schemaId) => SchemaHelpers.FormatSchemaName(schemaId);
	public bool IsValueType(string typeName) => SchemaHelpers.IsValueType(typeName);
	public bool IsLinkedType(string typeName) => Analyzer.IsLinkedType(typeName);
	public bool IsPrimitiveTypeName(string typeName) => SchemaHelpers.IsPrimitiveTypeName(typeName);
	public string? GetValueTypeBase(IOpenApiSchema? schema) => SchemaHelpers.GetValueTypeBase(schema);
	public string? GetPrimitiveAliasType(IOpenApiSchema? schema) => SchemaHelpers.GetPrimitiveAliasType(schema);

	// Keep rendering functions that produce HTML - these will eventually become partials
	public IHtmlContent RenderSchemaType(IOpenApiSchema schema, HashSet<string>? ancestorTypes = null)
	{
		var info = GetTypeInfo(schema);
		var sb = new System.Text.StringBuilder();

		// Check if this type actually has properties (for showing {} icon)
		var hasActualProperties = GetSchemaProperties(schema)?.Count > 0;

		// Build the display text with [] for arrays, {} for objects, enum/union markers
		if (info.IsArray)
		{
			sb.Append("<span class=\"array-icon\">[] </span>");
			if (info.IsValueType && info.ValueTypeBase != null)
			{
				sb.Append($"{info.ValueTypeBase} ");
			}
			else if (info.IsEnum)
			{
				sb.Append("<span class=\"enum-icon\">enum </span>");
			}
			else if (info.IsUnion)
			{
				sb.Append("<span class=\"union-icon\">union </span>");
			}
			else if (info.IsObject && !string.IsNullOrEmpty(info.SchemaRef) && (hasActualProperties || info.HasLink))
			{
				sb.Append("<span class=\"object-icon\">{} </span>");
			}
		}
		else if (info.IsDictionary)
		{
			// Dictionary uses "map string to TypeName" format
			// Extract the value type name from the TypeName (format: "string to TypeName")
			var valueTypeName = info.TypeName.StartsWith("string to ") ? info.TypeName["string to ".Length..] : info.TypeName;
			var dictValueHasProps = info.DictValueSchema != null && GetSchemaProperties(info.DictValueSchema)?.Count > 0;
			var showObjectIcon = info.HasLink || dictValueHasProps;

			// Format: "map string to {} ScriptField" with "string" and "ScriptField" as types (blue)
			sb.Append("<span class=\"map-keyword\">map </span>");
			sb.Append("<span>string</span>");
			sb.Append("<span class=\"map-keyword\"> to </span>");
			if (showObjectIcon)
			{
				sb.Append("<span class=\"object-icon\">{} </span>");
			}
			sb.Append($"<span>{System.Web.HttpUtility.HtmlEncode(valueTypeName)}</span>");
			return new HtmlString($"<code class=\"schema-type\">{sb}</code>");
		}
		else if (info.IsEnum)
		{
			// Enum marker
			sb.Append("<span class=\"enum-icon\">enum </span>");
		}
		else if (info.IsUnion)
		{
			// Union marker
			sb.Append("<span class=\"union-icon\">union </span>");
		}
		else if (info.IsValueType && info.ValueTypeBase != null)
		{
			// Show underlying type for named value types: "string Field" instead of just "Field"
			sb.Append($"<span class=\"value-type-keyword\">{info.ValueTypeBase}</span> ");
		}
		else if (info.IsObject && !string.IsNullOrEmpty(info.SchemaRef) && !info.HasLink && hasActualProperties)
		{
			// Regular objects get {} only if they have properties
			sb.Append("<span class=\"object-icon\">{} </span>");
		}

		var displayName = System.Web.HttpUtility.HtmlEncode(info.TypeName);
		var titleAttr = !string.IsNullOrEmpty(info.SchemaRef) ? $" title=\"{info.SchemaRef}\"" : "";

		// Add {} prefix for linked types (they have dedicated pages)
		if (info.HasLink && !info.IsDictionary)
		{
			sb.Append("<span class=\"object-icon\">{} </span>");
		}

		sb.Append($"<span{titleAttr}>{displayName}</span>");

		return new HtmlString($"<code class=\"schema-type\">{sb}</code>");
	}

	public IHtmlContent RenderRecursiveBadge()
	{
		return new HtmlString("<span class=\"recursive\">recursive</span>");
	}

	public IHtmlContent RenderUnionOptions(List<UnionOption> options, string prefix, int depth, HashSet<string>? ancestorTypes = null, bool isRequest = false)
	{
		if (options.Count == 0)
			return HtmlString.Empty;

		// If ALL options are value types (no objects), don't render tree nodes
		// The "One of:" badges are sufficient for simple unions like boolean | number
		var hasObjectOption = options.Any(o => o.IsObject);
		if (!hasObjectOption)
			return HtmlString.Empty;

		// Use original options list to include ALL types (objects AND primitives)
		// Sort: array variants first, then non-array variants
		// Group by base name to pair X[] with X
		var sortedOptions = options
			.GroupBy(o => o.Name.EndsWith("[]") ? o.Name[..^2] : o.Name)
			.SelectMany(g => {
				var items = g.ToList();
				// Sort within group: array first, then non-array
				return items.OrderByDescending(o => o.Name.EndsWith("[]"));
			})
			.ToList();

		// Build list of variants to render - include ALL types (both objects and primitives)
		var variantsToRender = new List<(string Name, string BaseName, bool IsArray, bool IsObject, IOpenApiSchema? Schema, IDictionary<string, IOpenApiSchema>? Props)>();

		// Group by base name
		var typeGroups = sortedOptions
			.GroupBy(o => o.Name.EndsWith("[]") ? o.Name[..^2] : o.Name)
			.ToDictionary(g => g.Key, g => g.ToList());

		foreach (var (baseName, variants) in typeGroups)
		{
			// Find the non-array variant to get schema info (or use array if no non-array)
			var primaryOption = variants.FirstOrDefault(o => !o.Name.EndsWith("[]"));
			if (primaryOption?.Schema is null)
				primaryOption = variants.First();

			IOpenApiSchema? schemaToRender = primaryOption.Schema;
			IDictionary<string, IOpenApiSchema>? optionProps = null;

			// Try to get properties for object types
			if (primaryOption.IsObject && schemaToRender != null)
			{
				optionProps = GetSchemaProperties(schemaToRender);

				if (optionProps is null || optionProps.Count == 0)
				{
					var refId = primaryOption.Ref;
					if (string.IsNullOrEmpty(refId) && schemaToRender is OpenApiSchemaReference schemaRef)
						refId = schemaRef.Reference?.Id;

					if (!string.IsNullOrEmpty(refId) && Model.Document.Components?.Schemas?.TryGetValue(refId, out var resolvedSchema) == true)
					{
						optionProps = GetSchemaProperties(resolvedSchema);
						schemaToRender = resolvedSchema;
					}
					else if (Model.Document.Components?.Schemas != null)
					{
						var matchingSchema = Model.Document.Components.Schemas
							.FirstOrDefault(kvp => kvp.Key.EndsWith("." + baseName) || kvp.Key == baseName);
						if (matchingSchema.Value != null)
						{
							optionProps = GetSchemaProperties(matchingSchema.Value);
							schemaToRender = matchingSchema.Value;
						}
					}
				}
			}

			// Check if this type has both array and non-array variants
			var hasArrayVariant = variants.Any(v => v.Name.EndsWith("[]"));
			var hasNonArrayVariant = variants.Any(v => !v.Name.EndsWith("[]"));

			if (hasArrayVariant && hasNonArrayVariant)
			{
				// Render both: array first (no properties), then non-array (with properties)
				variantsToRender.Add(($"{baseName}[]", baseName, true, primaryOption.IsObject, schemaToRender, optionProps));
				variantsToRender.Add((baseName, baseName, false, primaryOption.IsObject, schemaToRender, optionProps));
			}
			else if (hasArrayVariant)
			{
				variantsToRender.Add(($"{baseName}[]", baseName, true, primaryOption.IsObject, schemaToRender, optionProps));
			}
			else
			{
				variantsToRender.Add((baseName, baseName, false, primaryOption.IsObject, schemaToRender, optionProps));
			}
		}

		// If no variants to render, nothing to show
		if (variantsToRender.Count == 0)
			return HtmlString.Empty;

		// Check if we should collapse the union options (more than 2 variants)
		var shouldCollapseUnion = variantsToRender.Count > 2;
		var unionContainerId = $"{prefix}-union-options";

		// Show union variants - type labels with tree-style connectors
		// Object types with properties get expand/collapse
		<div class="union-variants-container @(shouldCollapseUnion ? "collapsible collapsed" : "")" id="@unionContainerId">
			@if (shouldCollapseUnion)
			{
				<div class="union-collapse-toggle">
					<button class="expand-toggle union-group-toggle">
						<span class="toggle-icon">+</span>
						<span class="toggle-label">Show @variantsToRender.Count type options</span>
					</button>
				</div>
			}
			<div class="union-variants @(shouldCollapseUnion ? "union-variants-content" : "")" @(shouldCollapseUnion ? "hidden=\"until-found\"" : "")>
			@for (var i = 0; i < variantsToRender.Count; i++)
			{
				var variant = variantsToRender[i];
				var variantName = variant.Name;
				var baseName = variant.BaseName;
				var isArrayVariant = variant.IsArray;
				var isObjectType = variant.IsObject;
				var schemaToRender = variant.Schema;
				var optionProps = variant.Props;
				var hasProperties = optionProps != null && optionProps.Count > 0;

				var optionId = $"{prefix}-variant-{variantName.ToLowerInvariant().Replace(" ", "-").Replace("[]", "-array")}";

				// Only show properties for non-array variant when both exist (to avoid duplication)
				var hasBothVariants = variantsToRender.Count(v => v.BaseName == baseName) > 1;
				var showProperties = hasProperties && (!isArrayVariant || !hasBothVariants);

				// Build ancestor set including current variant type
				var newAncestors = ancestorTypes != null ? new HashSet<string>(ancestorTypes) : new HashSet<string>();
				if (!string.IsNullOrEmpty(baseName))
					newAncestors.Add(baseName);

				// Add separator before each variant except the first
				@if (i > 0)
				{
					<div class="union-separator">or</div>
				}

				// Render as type label (no tree connectors)
				// Object types with properties are collapsible
				var nestedPropCount = optionProps?.Count ?? 0;
				var isCollapsible = showProperties && nestedPropCount > 1;

				<div class="union-variant-item @(showProperties ? "has-children" : "") @(isCollapsible ? "collapsed" : "")" id="@optionId">
					<div class="union-variant-label">
						@if (isArrayVariant)
						{
							<span class="array-icon">[]</span>
						}
						@if (isObjectType)
						{
							<span class="object-icon">{}</span>
						}
						@{
							// Remove [] suffix from name when we already show [] icon prefix
							var displayVariantName = isArrayVariant && variantName.EndsWith("[]") ? variantName[..^2] : variantName;
						}
						<code class="schema-type">@displayVariantName</code>
					</div>
					@if (showProperties && schemaToRender != null)
					{
						@if (isCollapsible)
						{
							<div class="expand-toggle-row union-expand-toggle">
								<button class="expand-toggle">
									<span class="toggle-icon">+</span>
									<span class="toggle-label">Show @nestedPropCount properties</span>
								</button>
							</div>
						}
						@if (isCollapsible)
						{
							<div class="nested-properties" id="@optionId-children" hidden="until-found">
								@RenderProperties(schemaToRender, null, optionId, depth + 1, newAncestors, isRequest)
							</div>
						}
						else
						{
							<div class="nested-properties" id="@optionId-children">
								@RenderProperties(schemaToRender, null, optionId, depth + 1, newAncestors, isRequest)
							</div>
						}
					}
				</div>
			}
			</div>
		</div>

		return HtmlString.Empty;
	}

	public IHtmlContent RenderProperties(IOpenApiSchema? schema, ISet<string>? required, string prefix, int depth, HashSet<string>? ancestorTypes = null, bool isRequest = false)
	{
		var properties = GetSchemaProperties(schema);
		if (properties is null || properties.Count == 0)
			return HtmlString.Empty;

		var requiredProps = required ?? schema?.Required ?? new HashSet<string>();
		var propArray = properties.ToArray();

		<dl class="property-list">
			@for (var i = 0; i < propArray.Length; i++)
			{
				var property = propArray[i];
				var propSchema = property.Value;
				if (propSchema is null) continue;
				var isRequired = requiredProps.Contains(property.Key);
				var typeInfo = GetTypeInfo(propSchema);
				var propId = string.IsNullOrEmpty(prefix) ? property.Key : $"{prefix}-{property.Key}";
				var isLast = i == propArray.Length - 1;
				var hasDescription = !string.IsNullOrWhiteSpace(propSchema.Description);

				// Check if this type appears in any ancestor (recursive detection)
				// Only consider named types - primitive types like "object", "string" cannot be recursive
				var isRecursive = ancestorTypes != null && !string.IsNullOrEmpty(typeInfo.TypeName)
					&& !IsPrimitiveTypeName(typeInfo.TypeName) && ancestorTypes.Contains(typeInfo.TypeName);

				// Also check dictionary value types for recursion (e.g., "aggregations" map string to AggregationContainer)
				if (!isRecursive && typeInfo.IsDictionary && typeInfo.DictValueSchema != null)
				{
					var dictValueType = GetTypeInfo(typeInfo.DictValueSchema);
					isRecursive = ancestorTypes != null && !string.IsNullOrEmpty(dictValueType.TypeName)
						&& !IsPrimitiveTypeName(dictValueType.TypeName) && ancestorTypes.Contains(dictValueType.TypeName);
				}

				// For dictionaries with linked value types, typeInfo.HasLink is true
				var dictHasLinkedValue = typeInfo.IsDictionary && typeInfo.HasLink;

				// Determine if we should show nested properties
				// Don't expand if the type has a dedicated page (linked type)
				var hasNestedProps = typeInfo.IsObject && !typeInfo.HasLink && depth < SchemaHelpers.MaxDepth && GetSchemaProperties(propSchema)?.Count > 0;

				// For dictionaries, check if the value type has properties we should show
				// Don't expand if the value type has a dedicated page (linked type)
				var hasDictValueProps = typeInfo.IsDictionary && typeInfo.DictValueSchema != null
					&& depth < SchemaHelpers.MaxDepth && !dictHasLinkedValue && GetSchemaProperties(typeInfo.DictValueSchema)?.Count > 0;

				// For arrays, check if the item type has properties we should show
				var arrayItemSchema = typeInfo.IsArray && propSchema.Items != null ? propSchema.Items : null;
				var hasArrayItemProps = arrayItemSchema != null && !typeInfo.HasLink && depth < SchemaHelpers.MaxDepth
					&& GetSchemaProperties(arrayItemSchema)?.Count > 0;

				// For union types, check if there are object options with properties (using helper with fallback resolution)
				// First, detect "simple" X | X[] unions - same base type, just one single and one array variant
				var isSimpleArrayUnion = false;
				string? simpleUnionBaseName = null;
				if (typeInfo.IsUnion && typeInfo.AnyOfOptions != null && typeInfo.AnyOfOptions.Count > 0)
				{
					var unionOptionNames = new List<string>();
					unionOptionNames.AddRange(typeInfo.AnyOfOptions.Select(o => o.Name));
					if (typeInfo.UnionOptions != null)
						unionOptionNames.AddRange(typeInfo.UnionOptions);
					var distinctNames = unionOptionNames.Distinct().ToArray();

					// Check if this is exactly X and X[] (same base type)
					if (distinctNames.Length == 2)
					{
						var baseNames = distinctNames.Select(n => n.EndsWith("[]") ? n[..^2] : n).Distinct().ToArray();
						if (baseNames.Length == 1 && !string.IsNullOrEmpty(baseNames[0]))
						{
							isSimpleArrayUnion = true;
							simpleUnionBaseName = baseNames[0];
						}
					}
				}

				// For simple X | X[] unions, don't expand tree - show inline instead
				var hasUnionOptions = typeInfo.IsUnion && typeInfo.AnyOfOptions != null && depth < SchemaHelpers.MaxDepth
					&& !isSimpleArrayUnion
					&& typeInfo.AnyOfOptions.Any(UnionOptionHasProperties);

				// For simple unions, check if the base type has properties we should expand (when NOT linked)
				var simpleUnionHasExpandableProps = false;
				IOpenApiSchema? simpleUnionSchema = null;
				List<UnionOption>? simpleUnionNestedOptions = null;
				if (isSimpleArrayUnion && !string.IsNullOrEmpty(simpleUnionBaseName) && typeInfo.AnyOfOptions != null && depth < SchemaHelpers.MaxDepth)
				{
					var baseOption = typeInfo.AnyOfOptions.FirstOrDefault(o => o.Name == simpleUnionBaseName);
					if (baseOption?.Schema != null)
					{
						var baseTypeInfo = GetTypeInfo(baseOption.Schema);
						// Only expand if NOT linked (linked types have their own page)
						if (!baseTypeInfo.HasLink && UnionOptionHasProperties(baseOption))
						{
							simpleUnionHasExpandableProps = true;
							simpleUnionSchema = baseOption.Schema;

							// Check if the base type is itself a nested union
							// If so, we need to render its nested union options, not try to get direct properties
							var directProps = GetSchemaProperties(baseOption.Schema);
							if (directProps == null || directProps.Count == 0)
							{
								// No direct properties - check if it's a nested union
								simpleUnionNestedOptions = GetNestedUnionOptions(baseOption.Schema);
								if (simpleUnionNestedOptions.Count == 0)
								{
									// Try resolving schema reference
									var refId = baseOption.Ref;
									if (string.IsNullOrEmpty(refId) && baseOption.Schema is OpenApiSchemaReference schemaRef)
										refId = schemaRef.Reference?.Id;
									if (!string.IsNullOrEmpty(refId) && Model.Document.Components?.Schemas?.TryGetValue(refId, out var resolvedSchema) == true)
									{
										simpleUnionNestedOptions = GetNestedUnionOptions(resolvedSchema);
									}
								}
							}
						}
					}
				}

				// Count nested properties
				var nestedPropCount = 0;
				if (hasNestedProps)
					nestedPropCount = GetSchemaProperties(propSchema)?.Count ?? 0;
				else if (hasDictValueProps && typeInfo.DictValueSchema != null)
					nestedPropCount = GetSchemaProperties(typeInfo.DictValueSchema)?.Count ?? 0;
				else if (hasArrayItemProps && arrayItemSchema != null)
					nestedPropCount = GetSchemaProperties(arrayItemSchema)?.Count ?? 0;
				else if (hasUnionOptions && typeInfo.AnyOfOptions != null)
					nestedPropCount = typeInfo.AnyOfOptions.Count(UnionOptionHasProperties);
				else if (simpleUnionHasExpandableProps && simpleUnionNestedOptions is { Count: > 0 })
					nestedPropCount = simpleUnionNestedOptions.Count(UnionOptionHasProperties);
				else if (simpleUnionHasExpandableProps && simpleUnionSchema != null)
					nestedPropCount = GetSchemaProperties(simpleUnionSchema)?.Count ?? 0;

				// Show collapse toggle if more than 1 property
				// Union types should NOT have expand/collapse - their type options are always visible as tree nodes
				// Dictionary types have their toggle at the <string> key level, not the parent level
				// Simple unions with expandable props should have toggle
				var hasChildren = (hasNestedProps || hasDictValueProps || hasArrayItemProps || hasUnionOptions || simpleUnionHasExpandableProps) && !isRecursive;
				var isCollapsible = hasChildren && nestedPropCount > 1 && !hasUnionOptions && !hasDictValueProps;

				// Always collapsed when toggle is shown (only 1 prop = no toggle, content visible)
				var defaultExpanded = false;

				<div class="property-item depth-@depth @(isLast ? "last-sibling" : "") @(hasChildren ? "has-children" : "") @(isCollapsible ? (defaultExpanded ? "expanded" : "collapsed") : "") @(propSchema.Deprecated == true ? "deprecated" : "")">
					<dt id="@propId">
						<a href="#@propId">
							<code>@property.Key</code>
							@RenderSchemaType(propSchema, ancestorTypes)
							@if (isRequest && isRequired)
							{
								<span class="required">required</span>
							}
							else if (!isRequest && !isRequired)
							{
								<span class="optional">optional</span>
							}
							@if (isRecursive)
							{
								@RenderRecursiveBadge()
							}
							@if (propSchema.Deprecated == true)
							{
								<span class="deprecated-badge">deprecated</span>
							}
							@{
								var propVersionInfo = propSchema.Extensions?.TryGetValue("x-state", out var propStateValue) == true && propStateValue is System.Text.Json.Nodes.JsonNode propStateNode ? propStateNode.ToString() : null;
							}
							@if (!string.IsNullOrEmpty(propVersionInfo))
							{
								<span class="version-badge">@propVersionInfo</span>
							}
						</a>
						@if (propSchema.ExternalDocs?.Url != null)
						{
							<a href="@propSchema.ExternalDocs.Url" class="external-docs-inline" target="_blank" rel="noopener" title="External documentation">docs</a>
						}
					</dt>
					@if (hasDescription)
					{
						<dd>
							@Model.RenderMarkdown(propSchema.Description)
						</dd>
					}
					@ValidationConstraintsRenderer.Render(propSchema)
					@if (typeInfo.IsEnum && typeInfo.EnumValues is { Length: > 0 })
					{
						<dd class="enum-values">
							<span class="values-label">Values:</span>
							@foreach (var enumVal in typeInfo.EnumValues)
							{
								<code class="enum-value">@enumVal</code>
							}
						</dd>
					}
					@if (typeInfo.IsUnion)
					{
						// Merge AnyOfOptions names with UnionOptions for complete coverage
						// AnyOfOptions has complex types with schemas, UnionOptions has all names including primitives
						var unionOptionNames = new List<string>();
						if (typeInfo.AnyOfOptions != null && typeInfo.AnyOfOptions.Count > 0)
							unionOptionNames.AddRange(typeInfo.AnyOfOptions.Select(o => o.Name));
						if (typeInfo.UnionOptions != null)
							unionOptionNames.AddRange(typeInfo.UnionOptions);
						var distinctOptions = unionOptionNames.Distinct().ToArray();

						// For X | X[] unions, show X[] first
						var sortedOptions = distinctOptions
							.OrderByDescending(o => o.EndsWith("[]"))
							.ToArray();

						// Check if all options are enum-like (primitive string values, not types with PascalCase or [])
						// Enum values are typically lowercase like "avg", "max", "none"
						// Type names are typically PascalCase like "Rescore", "SortOptions"
						// Primitive types (boolean, number, string, etc.) are NOT enum-like even though they're lowercase
						var primitiveTypeNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
							{ "boolean", "number", "string", "integer", "object", "null", "array" };
						var allEnumLike = sortedOptions.Length > 0 && sortedOptions.All(o =>
							!o.EndsWith("[]") &&
							!string.IsNullOrEmpty(o) &&
							!primitiveTypeNames.Contains(o) &&
							(char.IsLower(o[0]) || o.All(c => !char.IsLetter(c) || char.IsLower(c) || c == '_')));

						if (allEnumLike)
						{
							<dd class="enum-values">
								<span class="values-label">Values:</span>
								@foreach (var enumVal in sortedOptions)
								{
									<code class="enum-value">@enumVal</code>
								}
							</dd>
						}
						else if (isSimpleArrayUnion && !string.IsNullOrEmpty(simpleUnionBaseName))
						{
							// Simple X | X[] union - show horizontal layout
							// Check if the base type is an object type or a value type
							var baseTypeOption = typeInfo.AnyOfOptions?.FirstOrDefault(o => o.Name == simpleUnionBaseName);
							var isObjectType = baseTypeOption?.IsObject ?? false;
							// Check if the base type is a named value type (e.g., Field = string)
							var baseSchema = baseTypeOption?.Schema;
							var baseTypeInfo = baseSchema != null ? GetTypeInfo(baseSchema) : null;
							var isBaseValueType = baseTypeInfo?.IsValueType ?? false;
							var valueTypePrefix = isBaseValueType && !string.IsNullOrEmpty(baseTypeInfo?.ValueTypeBase)
								? baseTypeInfo.ValueTypeBase + " "
								: "";
							<dd class="union-inline-row">
								<span class="values-label">One of:</span>
								<span class="union-inline-options">
									<span class="union-inline-option">
										@if (isObjectType)
										{
											<span class="object-icon">{}</span>
										}
										<code class="schema-type"><span>@valueTypePrefix@simpleUnionBaseName</span></code>
									</span>
									<span class="union-inline-separator">or</span>
									<span class="union-inline-option">
										<span class="array-icon">[]</span>
										@if (isObjectType)
										{
											<span class="object-icon">{}</span>
										}
										<code class="schema-type"><span>@valueTypePrefix@simpleUnionBaseName</span></code>
									</span>
								</span>
							</dd>
						}
						else if (sortedOptions.Length > 0 || hasUnionOptions)
						{
							// Always show "One of:" label when we have union options
							// If hasUnionOptions is true, all types are rendered as tree nodes (including value types)
							// so we don't show any badges - they all appear in the tree below
							// Only show badges when there are NO tree nodes (all value types)
							var badgeOptions = hasUnionOptions ? Array.Empty<string>() : sortedOptions;

							// Primitive types that should render as types, not enum values
							var primitiveTypes = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
								{ "boolean", "number", "string", "integer", "object", "null", "array" };

							<dd class="union-options">
								<span class="values-label">One of:</span>
								@if (propSchema.Discriminator?.PropertyName != null)
								{
									<span class="discriminator-note">(determined by <code>@propSchema.Discriminator.PropertyName</code>)</span>
								}
								@{var badgeIndex = 0;}
								@foreach (var unionOpt in badgeOptions)
								{
									if (badgeIndex > 0)
									{
										<span class="union-inline-separator">or</span>
									}
									// Use type styling for primitive types or PascalCase type names
									// Enum values are typically lowercase like "avg", "max", "none"
									var isTypeOption = primitiveTypes.Contains(unionOpt) ||
										primitiveTypes.Contains(unionOpt.TrimEnd('[', ']')) ||
										char.IsUpper(unionOpt[0]) || unionOpt.EndsWith("[]");
									<code class="@(isTypeOption ? "union-type-option" : "union-option")">@unionOpt</code>
									badgeIndex++;
								}
							</dd>
						}
					}
					@if (!string.IsNullOrEmpty(typeInfo.ArrayItemType))
					{
						<dd class="primitive-array">
							<span class="values-label">Array of:</span>
							<code class="primitive-type">@typeInfo.ArrayItemType</code>
						</dd>
					}
					@{
						// Add link to type page for linked types
						// For simple X | X[] unions, check if the base type has a linked page
						string? linkedTypeName = null;
						if (typeInfo.HasLink)
						{
							linkedTypeName = typeInfo.IsDictionary && typeInfo.DictValueSchema != null
								? GetTypeInfo(typeInfo.DictValueSchema).TypeName
								: typeInfo.TypeName;
						}
						else if (isSimpleArrayUnion && !string.IsNullOrEmpty(simpleUnionBaseName) && typeInfo.AnyOfOptions != null)
						{
							// Check if the base type in the simple union is a linked type
							var baseOption = typeInfo.AnyOfOptions.FirstOrDefault(o => o.Name == simpleUnionBaseName);
							if (baseOption?.Schema != null)
							{
								var baseTypeInfo = GetTypeInfo(baseOption.Schema);
								if (baseTypeInfo.HasLink)
									linkedTypeName = simpleUnionBaseName;
							}
						}
					}
					@if (!string.IsNullOrEmpty(linkedTypeName))
					{
						var typePageUrl = GetContainerPageUrl(linkedTypeName);
						<dd class="type-link-description">
							<a href="@typePageUrl" data-hx-boost="false">See @linkedTypeName type →</a>
						</dd>
					}
					@if (isCollapsible)
					{
						<dd class="expand-toggle-row">
							<button class="expand-toggle" aria-expanded="@(defaultExpanded ? "true" : "false")" aria-controls="@propId-children" title="@(defaultExpanded ? "Collapse" : "Expand") @nestedPropCount properties">
								<span class="toggle-icon">@(defaultExpanded ? "−" : "+")</span>
								<span class="toggle-label">@(defaultExpanded ? "Hide" : "Show") @nestedPropCount properties</span>
							</button>
						</dd>
					}
					@if (!isRecursive)
					{
						// Build new ancestor set including current type
						var newAncestors = ancestorTypes != null ? new HashSet<string>(ancestorTypes) : new HashSet<string>();
						if (!string.IsNullOrEmpty(typeInfo.TypeName) && typeInfo.IsObject)
						{
							// For dictionaries, add the value type name rather than "string to X"
							if (typeInfo.IsDictionary && typeInfo.DictValueSchema != null)
							{
								var dictValueType = GetTypeInfo(typeInfo.DictValueSchema);
								if (!string.IsNullOrEmpty(dictValueType.TypeName))
									newAncestors.Add(dictValueType.TypeName);
							}
							else
							{
								newAncestors.Add(typeInfo.TypeName);
							}
						}

						if (hasDictValueProps && typeInfo.DictValueSchema != null)
						{
							// Show dictionary with intermediary key level - key is always string for additionalProperties
							// The expand toggle appears at this <string> key level, not the parent property level
							var keyPropId = $"{propId}-string";
							var dictIsCollapsible = nestedPropCount > 1;
							var dictDefaultExpanded = false;
							<div class="nested-properties" id="@propId-children">
								<dl class="property-list">
									<div class="property-item depth-@(depth + 1) last-sibling has-children @(dictIsCollapsible ? (dictDefaultExpanded ? "expanded" : "collapsed") : "")">
										<dt id="@keyPropId">
											<code>&lt;string&gt;</code>
											@RenderSchemaType(typeInfo.DictValueSchema, newAncestors)
										</dt>
										@if (dictIsCollapsible)
										{
											<dd class="expand-toggle-row">
												<button class="expand-toggle" aria-expanded="@(dictDefaultExpanded ? "true" : "false")" aria-controls="@keyPropId-children" title="@(dictDefaultExpanded ? "Collapse" : "Expand") @nestedPropCount properties">
													<span class="toggle-icon">@(dictDefaultExpanded ? "−" : "+")</span>
													<span class="toggle-label">@(dictDefaultExpanded ? "Hide" : "Show") @nestedPropCount properties</span>
												</button>
											</dd>
										}
										@if (dictIsCollapsible && !dictDefaultExpanded)
										{
											<div class="nested-properties" id="@keyPropId-children" hidden="until-found">
												@RenderProperties(typeInfo.DictValueSchema, null, keyPropId, depth + 2, newAncestors, isRequest)
											</div>
										}
										else
										{
											<div class="nested-properties" id="@keyPropId-children">
												@RenderProperties(typeInfo.DictValueSchema, null, keyPropId, depth + 2, newAncestors, isRequest)
											</div>
										}
									</div>
								</dl>
							</div>
						}
						else if (hasNestedProps)
						{
							@if (isCollapsible && !defaultExpanded)
							{
								<div class="nested-properties" id="@propId-children" hidden="until-found">
									@RenderProperties(propSchema, null, propId, depth + 1, newAncestors, isRequest)
								</div>
							}
							else
							{
								<div class="nested-properties" id="@propId-children">
									@RenderProperties(propSchema, null, propId, depth + 1, newAncestors, isRequest)
								</div>
							}
						}
						else if (hasArrayItemProps && arrayItemSchema != null)
						{
							// Show array item properties
							@if (isCollapsible && !defaultExpanded)
							{
								<div class="nested-properties" id="@propId-children" hidden="until-found">
									@RenderProperties(arrayItemSchema, null, propId, depth + 1, newAncestors, isRequest)
								</div>
							}
							else
							{
								<div class="nested-properties" id="@propId-children">
									@RenderProperties(arrayItemSchema, null, propId, depth + 1, newAncestors, isRequest)
								</div>
							}
						}
						else if (hasUnionOptions && typeInfo.AnyOfOptions != null)
						{
							// Show union variant options (these are not collapsible at this level)
							<div class="nested-properties" id="@propId-children">
								@RenderUnionOptions(typeInfo.AnyOfOptions, propId, depth + 1, newAncestors, isRequest)
							</div>
						}
						else if (simpleUnionHasExpandableProps && simpleUnionNestedOptions is { Count: > 0 })
						{
							// Show nested union options for simple X | X[] union where X is itself a union
							@if (isCollapsible && !defaultExpanded)
							{
								<div class="nested-properties" id="@propId-children" hidden="until-found">
									@RenderUnionOptions(simpleUnionNestedOptions, propId, depth + 1, newAncestors, isRequest)
								</div>
							}
							else
							{
								<div class="nested-properties" id="@propId-children">
									@RenderUnionOptions(simpleUnionNestedOptions, propId, depth + 1, newAncestors, isRequest)
								</div>
							}
						}
						else if (simpleUnionHasExpandableProps && simpleUnionSchema != null)
						{
							// Show properties for simple X | X[] union (non-linked type with direct properties)
							@if (isCollapsible && !defaultExpanded)
							{
								<div class="nested-properties" id="@propId-children" hidden="until-found">
									@RenderProperties(simpleUnionSchema, null, propId, depth + 1, newAncestors, isRequest)
								</div>
							}
							else
							{
								<div class="nested-properties" id="@propId-children">
									@RenderProperties(simpleUnionSchema, null, propId, depth + 1, newAncestors, isRequest)
								</div>
							}
						}
					}
				</div>
			}
		</dl>

		return HtmlString.Empty;
	}
}
@{
	var self = Model.CurrentNavigationItem as OperationNavigationItem;
	var allOperations =
		Model.CurrentNavigationItem.Parent is EndpointNavigationItem { NavigationItems.Count: > 0 } parent && parent.NavigationItems.All(n => n.Hidden)
			? parent.NavigationItems
			: self is not null
				? [self]
				: [];

	var operation = Model.Operation.Operation;
}

<section id="elastic-api-v3">
	<h1>
		@operation.Summary
		@if (operation.Deprecated == true)
		{
			<span class="deprecated-badge">deprecated</span>
		}
		@{
			var isBeta = operation.Extensions?.TryGetValue("x-beta", out var betaValue) == true && betaValue is System.Text.Json.Nodes.JsonNode betaNode && betaNode.GetValue<bool>();
		}
		@if (isBeta)
		{
			<span class="beta-badge">Beta</span>
		}
		@{
			var versionInfo = operation.Extensions?.TryGetValue("x-state", out var stateValue) == true && stateValue is System.Text.Json.Nodes.JsonNode stateNode ? stateNode.ToString() : null;
		}
		@if (!string.IsNullOrEmpty(versionInfo))
		{
			<span class="version-badge">@versionInfo</span>
		}
	</h1>
	<span style="background:cyan; display:none;" id="debug-version">DEBUG: Extensions=@(operation.Extensions != null ? string.Join(",", operation.Extensions.Keys) : "null"), x-state=@(versionInfo ?? "null")</span>
	<span style="background:yellow; display:none;" id="debug-externaldocs">DEBUG: ExternalDocs=@(operation.ExternalDocs != null ? "exists" : "null"), Url=@(operation.ExternalDocs?.Url?.ToString() ?? "null")</span>
	@if (operation.ExternalDocs?.Url != null)
	{
		<a href="@operation.ExternalDocs.Url" class="external-docs-link" target="_blank" rel="noopener">
			Documentation
		</a>
	}
	@{
		// Servers can be at operation level or document level
		var servers = operation.Servers is { Count: > 0 } ? operation.Servers : Model.Document.Servers;
	}
	@if (servers is { Count: > 0 })
	{
		<div class="server-info">
			<span class="server-label">Server@(servers.Count > 1 ? "s" : ""):</span>
			@foreach (var server in servers)
			{
				<span class="server-url">
					<code>@server.Url</code>
					@if (!string.IsNullOrEmpty(server.Description))
					{
						<span class="server-description">(@server.Description)</span>
					}
				</span>
			}
		</div>
	}

	<h3 class="section-header" id="paths" data-section="paths">
		<span>Paths</span>
		<span class="section-nav">
			<span class="section-path">@Model.Operation.Route</span>
			<button class="section-nav-btn" data-dir="up" title="Previous section">&#x25B2;</button>
			<button class="section-nav-btn" data-dir="down" title="Next section">&#x25BC;</button>
		</span>
	</h3>
	<ul class="api-url-listing">
		@foreach (var overload in allOperations)
		{
			var method = overload.Model.OperationType.ToString().ToLowerInvariant();
			var current = overload.Model.Route == Model.Operation.Route && overload.Model.OperationType == Model.Operation.OperationType ? "current" : "";
			var isDeprecated = overload.Model.Operation?.Deprecated == true;
			<li class="api-url-list-item @(isDeprecated ? "deprecated" : "")">
				<a href="@overload.Url" class="@current" hx-disable="true">
					 <span class="api-method api-method-@method">@method.ToUpperInvariant()</span>
					 <span class="api-url @(isDeprecated ? "deprecated-path" : "")">@overload.Model.Route</span>
					 @if (isDeprecated)
					 {
						 <span class="deprecated-badge">deprecated</span>
					 }
				</a>
			</li>
		}
	</ul>
	@{
		var pathParameters = operation.Parameters?.Where(p => p.In == ParameterLocation.Path).ToArray() ?? [];
	}
	@if (pathParameters.Length > 0)
	{
		<h4>Path Parameters</h4>
		<dl class="property-list">
		@foreach (var path in pathParameters)
		{
			<div class="path-param @(path.Deprecated == true ? "deprecated" : "")">
				<dt id="path-@path.Name">
					<a href="#path-@path.Name">
						<code>@path.Name</code>
						@if (path.Deprecated == true)
						{
							<span class="deprecated-badge">deprecated</span>
						}
					</a>
				</dt>
				<dd>@Model.RenderMarkdown(path.Description)</dd>
			</div>
		}
		</dl>
	}

	@if (!string.IsNullOrWhiteSpace(operation.Description))
	{
		<h3 class="section-header" id="description" data-section="description">
			<span>Description</span>
			<span class="section-nav">
				<span class="section-path">@Model.Operation.Route</span>
				<button class="section-nav-btn" data-dir="up" title="Previous section">&#x25B2;</button>
				<button class="section-nav-btn" data-dir="down" title="Next section">&#x25BC;</button>
			</span>
		</h3>
		<p>
			@(Model.RenderMarkdown(operation.Description))
		</p>
	}

	@if (operation.Security is { Count: > 0 })
	{
		<div class="security-requirements">
			<span class="security-label">Authorization:</span>
			@foreach (var requirement in operation.Security)
			{
				@foreach (var scheme in requirement)
				{
					<span class="security-scheme">
						<code>@scheme.Key.Name</code>
						@if (scheme.Value is { Count: > 0 })
						{
							<span class="security-scopes">(@string.Join(", ", scheme.Value))</span>
						}
					</span>
				}
			}
		</div>
	}

	@{
		var queryStringParameters = operation.Parameters?.Where(p => p.In == ParameterLocation.Query).ToArray() ?? [];
	}
	@if (queryStringParameters.Length > 0)
	{
		<h3 class="section-header" id="query-params" data-section="query-params">
			<span>Query String Parameters</span>
			<span class="section-nav">
				<span class="section-path">@Model.Operation.Route</span>
				<button class="section-nav-btn" data-dir="up" title="Previous section">&#x25B2;</button>
				<button class="section-nav-btn" data-dir="down" title="Next section">&#x25BC;</button>
			</span>
		</h3>
		<dl class="property-list">
			@foreach (var qs in queryStringParameters)
			{
				var qsSchema = qs.Schema;
				var resolvedQsSchema = qsSchema != null ? ResolveSchema(qsSchema) : null;

				// Collect enum values from direct enum, resolved enum, or union of string literals
				var qsEnumValues = new List<string>();
				if (qsSchema?.Enum is { Count: > 0 })
					qsEnumValues.AddRange(qsSchema.Enum.Select(e => e?.ToString()?.Trim('"') ?? "").Where(e => !string.IsNullOrEmpty(e)));
				else if (resolvedQsSchema?.Enum is { Count: > 0 })
					qsEnumValues.AddRange(resolvedQsSchema.Enum.Select(e => e?.ToString()?.Trim('"') ?? "").Where(e => !string.IsNullOrEmpty(e)));

				// Check for oneOf/anyOf with string literals (union enums)
				if (qsEnumValues.Count == 0)
				{
					var unionSchemas = resolvedQsSchema?.OneOf is { Count: > 0 } ? resolvedQsSchema.OneOf
						: resolvedQsSchema?.AnyOf is { Count: > 0 } ? resolvedQsSchema.AnyOf
						: null;
					if (unionSchemas != null)
					{
						foreach (var us in unionSchemas)
						{
							// Resolve the reference if us is a $ref
							var resolvedUnionOption = ResolveSchema(us);
							if (resolvedUnionOption?.Enum is { Count: > 0 })
								qsEnumValues.AddRange(resolvedUnionOption.Enum.Select(e => e?.ToString()?.Trim('"') ?? "").Where(e => !string.IsNullOrEmpty(e)));
						}
					}
				}

					// Get TypeInfo for union options display
				var qsTypeInfo = qsSchema != null ? GetTypeInfo(qsSchema) : null;

					// Collect union option names for "One of:" display
				var qsUnionOptions = new List<string>();
				if (qsTypeInfo?.AnyOfOptions is { Count: > 0 })
				{
					qsUnionOptions.AddRange(qsTypeInfo.AnyOfOptions.Select(o => o.Name).Where(n => !string.IsNullOrEmpty(n)));
				}
				else if (qsTypeInfo?.UnionOptions is { Length: > 0 })
				{
					qsUnionOptions.AddRange(qsTypeInfo.UnionOptions.Where(n => !string.IsNullOrEmpty(n)));
				}

				<div class="query-param @(qs.Deprecated == true ? "deprecated" : "")">
					<dt id="query-@qs.Name">
						<a href="#query-@qs.Name">
							<code>@qs.Name</code>
							@if (qsSchema != null)
							{
								@RenderSchemaType(qsSchema)
							}
							@if (qs.Deprecated == true)
							{
								<span class="deprecated-badge">deprecated</span>
							}
						</a>
					</dt>
					<dd>@Model.RenderMarkdown(qs.Description)</dd>
					@if (qsSchema != null)
					{
						@ValidationConstraintsRenderer.Render(qsSchema)
					}
				@if (qsUnionOptions.Count > 0 && qsEnumValues.Count == 0)
				{
					var primitiveTypes = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
						{ "boolean", "number", "string", "integer", "object", "null", "array" };
					<dd class="union-options">
						<span class="values-label">One of:</span>
						@{var optIndex = 0;}
						@foreach (var unionOpt in qsUnionOptions)
						{
							if (optIndex > 0)
							{
								<span class="union-inline-separator">or</span>
							}
							var isTypeOption = primitiveTypes.Contains(unionOpt) ||
								primitiveTypes.Contains(unionOpt.TrimEnd('[', ']')) ||
								char.IsUpper(unionOpt[0]) || unionOpt.EndsWith("[]");
							<code class="@(isTypeOption ? "union-type-option" : "union-option")">@unionOpt</code>
							optIndex++;
						}
					</dd>
				}
				@if (qsEnumValues.Count > 0)
				{
					<dd class="enum-values">
						<span class="values-label">Values:</span>
						@foreach (var enumVal in qsEnumValues)
						{
							<code class="enum-value">@enumVal</code>
						}
					</dd>
				}
				</div>
			}
		</dl>
	}
	@if (operation.RequestBody is not null)
	{
		var requestContent = operation.RequestBody.Content?.FirstOrDefault();
		var requestContentType = requestContent?.Key ?? "application/json";
		<h3 class="section-header" id="request-body" data-section="request-body">
			<span>Request Body</span>
			<span class="content-type-badge">@requestContentType</span>
			<span class="section-nav">
				<span class="section-path">@Model.Operation.Route</span>
				<button class="section-nav-btn" data-dir="up" title="Previous section">&#x25B2;</button>
				<button class="section-nav-btn" data-dir="down" title="Next section">&#x25BC;</button>
			</span>
		</h3>
		var content = requestContent?.Value;
		if (!string.IsNullOrEmpty(operation.RequestBody.Description))
		{
			<p>@Model.RenderMarkdown(operation.RequestBody.Description)</p>
		}

		var requestSchema = content?.Schema;
		if (requestSchema is not null)
		{
			var props = GetSchemaProperties(requestSchema);
			if (props is { Count: > 0 })
			{
				@RenderProperties(requestSchema, null, "req", 0, null, isRequest: true)
			}
			else
			{
				<p>Type: @RenderSchemaType(requestSchema)</p>
			}
		}
	}

	@if (operation.Responses is { Count: > 0 })
	{
		var isSingleResponse = operation.Responses.Count == 1;
		var singleResponse = isSingleResponse ? operation.Responses.First() : default;
		var singleContentType = isSingleResponse && singleResponse.Value?.Content?.Count > 0
			? singleResponse.Value.Content.First().Key
			: null;

		<h3 class="section-header" id="responses" data-section="responses">
			<span>@(isSingleResponse ? "Response" : "Responses")</span>
			@if (!string.IsNullOrEmpty(singleContentType))
			{
				<span class="content-type-badge">@singleContentType</span>
			}
			<span class="section-nav">
				<span class="section-path">@Model.Operation.Route</span>
				<button class="section-nav-btn" data-dir="up" title="Previous section">&#x25B2;</button>
				<button class="section-nav-btn" data-dir="down" title="Next section">&#x25BC;</button>
			</span>
		</h3>
		@foreach (var response in operation.Responses)
		{
			var statusCode = response.Key;
			var responseValue = response.Value;
			if (responseValue is null) continue;
			var statusClass = statusCode.StartsWith("2") ? "success" : statusCode.StartsWith("4") || statusCode.StartsWith("5") ? "error" : "info";
			<div class="response-section">
				@if (!isSingleResponse)
				{
					<h4>
						<span class="status-code status-@statusClass">@statusCode</span>
						@if (!string.IsNullOrEmpty(responseValue.Description))
						{
							<span class="response-description">@responseValue.Description</span>
						}
					</h4>
				}
				@if (responseValue.Content is { Count: > 0 })
				{
					foreach (var contentType in responseValue.Content)
					{
						if (contentType.Value?.Schema is not { } responseSchema) continue;
						@if (!isSingleResponse)
						{
							<p class="content-type">Content-Type: <code>@contentType.Key</code></p>
						}
						var responseProps = GetSchemaProperties(responseSchema);
						var responseTypeInfo = GetTypeInfo(responseSchema);

						// For arrays, check if the item type has properties we should render
						IOpenApiSchema? arrayItemSchema = null;
						IDictionary<string, IOpenApiSchema>? arrayItemProps = null;
						if (responseTypeInfo.IsArray)
						{
							// Try getting Items - handle schema references which may need explicit resolution
							arrayItemSchema = responseSchema.Items;
							if (arrayItemSchema is null && responseSchema is OpenApiSchemaReference respSchemaRef)
							{
								var respRefId = respSchemaRef.Reference?.Id;
								if (!string.IsNullOrEmpty(respRefId) &&
									Model.Document.Components?.Schemas?.TryGetValue(respRefId, out var resolvedRespSchema) == true)
								{
									arrayItemSchema = resolvedRespSchema.Items;
								}
							}
							if (arrayItemSchema is not null)
							{
								arrayItemProps = GetSchemaProperties(arrayItemSchema);
							}
						}

						if (responseProps is { Count: > 0 })
						{
							@RenderProperties(responseSchema, null, $"res-{statusCode}", 0)
						}
						else if (arrayItemProps is { Count: > 0 } && arrayItemSchema is not null)
						{
							// Array of objects - show the type annotation and render item properties
							<p>Response Type: @RenderSchemaType(responseSchema)</p>
							@RenderProperties(arrayItemSchema, null, $"res-{statusCode}", 0)
						}
						else
						{
							<p>Response Type: @RenderSchemaType(responseSchema)</p>
						}
					}
				}
				@if (responseValue.Headers is { Count: > 0 })
				{
					<div class="response-headers">
						<h5>Response Headers</h5>
						<dl class="property-list">
							@foreach (var header in responseValue.Headers)
							{
								<div class="header-item">
									<dt id="header-@statusCode-@header.Key">
										<a href="#header-@statusCode-@header.Key">
											<code>@header.Key</code>
											@if (header.Value?.Schema != null)
											{
												@RenderSchemaType(header.Value.Schema)
											}
											@if (header.Value?.Required == true)
											{
												<span class="required">required</span>
											}
											@if (header.Value?.Deprecated == true)
											{
												<span class="deprecated-badge">deprecated</span>
											}
										</a>
									</dt>
									@if (!string.IsNullOrEmpty(header.Value?.Description))
									{
										<dd>@Model.RenderMarkdown(header.Value.Description)</dd>
									}
								</div>
							}
						</dl>
					</div>
				}
			</div>
		}
	}
	@{
		// Check for examples in request body
		var requestBodyContent = operation.RequestBody?.Content?.FirstOrDefault().Value;
		var requestExamples = requestBodyContent?.Examples;

		// Check for examples in the response
		var successResponse = operation.Responses?.FirstOrDefault(r => r.Key.StartsWith("2")).Value;
		var responseContent = successResponse?.Content?.FirstOrDefault().Value;
		var responseExamples = responseContent?.Examples;
	}
	@if (requestExamples is { Count: > 0 })
	{
		<h3 class="section-header" id="request-examples" data-section="request-examples">
			<span>Request Examples</span>
			<span class="section-nav">
				<span class="section-path">@Model.Operation.Route</span>
				<button class="section-nav-btn" data-dir="up" title="Previous section">&#x25B2;</button>
				<button class="section-nav-btn" data-dir="down" title="Next section">&#x25BC;</button>
			</span>
		</h3>
		@foreach (var example in requestExamples)
		{
			<div class="example-block">
				<h4>@(string.IsNullOrEmpty(example.Value?.Summary) ? example.Key : example.Value.Summary)</h4>
				@if (!string.IsNullOrEmpty(example.Value?.Description))
				{
					<div class="example-description">@Model.RenderMarkdown(example.Value.Description)</div>
				}
				@if (example.Value?.Value is not null)
				{
					<pre><code class="language-json">@example.Value.Value.ToString()</code></pre>
				}
				@if (!string.IsNullOrEmpty(example.Value?.ExternalValue))
				{
					<p class="external-example">External example: <a href="@example.Value.ExternalValue">@example.Value.ExternalValue</a></p>
				}
			</div>
		}
	}
	@if (responseExamples is { Count: > 0 })
	{
		<h3 class="section-header" id="response-examples" data-section="response-examples">
			<span>Response Examples</span>
			<span class="section-nav">
				<span class="section-path">@Model.Operation.Route</span>
				<button class="section-nav-btn" data-dir="up" title="Previous section">&#x25B2;</button>
				<button class="section-nav-btn" data-dir="down" title="Next section">&#x25BC;</button>
			</span>
		</h3>
		@foreach (var example in responseExamples)
		{
			<div class="example-block">
				<h4>@(string.IsNullOrEmpty(example.Value?.Summary) ? example.Key : example.Value.Summary)</h4>
				@if (!string.IsNullOrEmpty(example.Value?.Description))
				{
					<div class="example-description">@Model.RenderMarkdown(example.Value.Description)</div>
				}
				@if (example.Value?.Value is not null)
				{
					<pre><code class="language-json">@example.Value.Value.ToString()</code></pre>
				}
				@if (!string.IsNullOrEmpty(example.Value?.ExternalValue))
				{
					<p class="external-example">External example: <a href="@example.Value.ExternalValue">@example.Value.ExternalValue</a></p>
				}
			</div>
		}
	}
	@{
		var hasExamples = requestExamples is { Count: > 0 } || responseExamples is { Count: > 0 };
		var examplesAnchor = requestExamples is { Count: > 0 } ? "request-examples" : "response-examples";
	}
	@if (hasExamples)
	{
		<a href="#@examplesAnchor" class="examples-jump-btn" id="examples-jump-btn">
			<span class="icon">&#x2193;</span>
			<span>Examples</span>
		</a>
	}
</section>

<script>
(function() {
	// Use event delegation on the section
	const section = document.getElementById('elastic-api-v3');
	if (!section) return;

	// Check if hidden="until-found" is supported
	const supportsHiddenUntilFound = 'onbeforematch' in document.body;

	// Helper function to expand a property item and all its ancestors
	function expandPropertyItem(propertyItem) {
		if (!propertyItem) return;

		const toggleBtn = propertyItem.querySelector(':scope > .expand-toggle-row > .expand-toggle');
		const nestedProps = propertyItem.querySelector(':scope > .nested-properties');

		propertyItem.classList.remove('collapsed');
		propertyItem.classList.add('expanded');

		if (toggleBtn) {
			toggleBtn.setAttribute('aria-expanded', 'true');
			const toggleIcon = toggleBtn.querySelector('.toggle-icon');
			const toggleLabel = toggleBtn.querySelector('.toggle-label');
			const propCount = toggleLabel?.textContent?.match(/\d+/)?.[0] || '';
			if (toggleIcon) toggleIcon.textContent = '−';
			if (toggleLabel) toggleLabel.textContent = `Hide ${propCount} properties`;
		}

		if (nestedProps) {
			nestedProps.removeAttribute('hidden');
		}

		// Recursively expand parent property items
		const parentItem = propertyItem.parentElement?.closest('.property-item, .union-variant-item');
		if (parentItem) {
			if (parentItem.classList.contains('union-variant-item')) {
				expandUnionVariantItem(parentItem);
			} else {
				expandPropertyItem(parentItem);
			}
		}
	}

	// Helper function to expand a union variant item and all its ancestors
	function expandUnionVariantItem(variantItem) {
		if (!variantItem) return;

		const toggleBtn = variantItem.querySelector(':scope > .union-expand-toggle > .expand-toggle');
		const nestedProps = variantItem.querySelector(':scope > .nested-properties');

		variantItem.classList.remove('collapsed');
		variantItem.classList.add('expanded');

		if (toggleBtn) {
			const toggleIcon = toggleBtn.querySelector('.toggle-icon');
			const toggleLabel = toggleBtn.querySelector('.toggle-label');
			const propCount = toggleLabel?.textContent?.match(/\d+/)?.[0] || '';
			if (toggleIcon) toggleIcon.textContent = '−';
			if (toggleLabel) toggleLabel.textContent = `Hide ${propCount} properties`;
		}

		if (nestedProps) {
			nestedProps.removeAttribute('hidden');
		}

		// Recursively expand parent items
		const parentItem = variantItem.parentElement?.closest('.property-item, .union-variant-item');
		if (parentItem) {
			if (parentItem.classList.contains('union-variant-item')) {
				expandUnionVariantItem(parentItem);
			} else {
				expandPropertyItem(parentItem);
			}
		}
	}

	// Add beforematch event listeners for hidden="until-found" elements (set server-side)
	// When find-in-page matches content inside collapsed sections, expand them
	if (supportsHiddenUntilFound) {
		section.querySelectorAll('.nested-properties[hidden="until-found"]').forEach(nestedProps => {
			nestedProps.addEventListener('beforematch', function(e) {
				const parentItem = nestedProps.parentElement;
				if (parentItem?.classList.contains('union-variant-item')) {
					expandUnionVariantItem(parentItem);
				} else if (parentItem?.classList.contains('property-item')) {
					expandPropertyItem(parentItem);
				}
			});
		});
	}

	// Scroll detection for section-path visibility
	// Find the trigger point - after Path Parameters header (or paths section if no path params)
	let triggerElement = null;

	// First check for Path Parameters header
	const pathParamsHeader = section.querySelector('h4');
	if (pathParamsHeader && pathParamsHeader.textContent?.includes('Path Parameters')) {
		triggerElement = pathParamsHeader;
	} else {
		// Fall back to the paths section URL listing
		const pathsHeader = section.querySelector('h3[data-section="paths"]');
		if (pathsHeader) {
			triggerElement = pathsHeader.nextElementSibling;
		}
	}

	function updateScrollState() {
		if (!triggerElement) return;

		const triggerBottom = triggerElement.getBoundingClientRect().bottom;
		const isScrolled = triggerBottom < 100; // 100px from top of viewport

		section.querySelectorAll('h3.section-header').forEach(header => {
			if (isScrolled) {
				header.classList.add('scrolled');
			} else {
				header.classList.remove('scrolled');
			}
		});
	}

	// Examples jump button visibility
	const examplesBtn = document.getElementById('examples-jump-btn');
	const examplesSection = section.querySelector('h3[data-section="request-examples"], h3[data-section="response-examples"]');

	function updateExamplesButtonVisibility() {
		if (!examplesBtn || !examplesSection) return;

		const examplesTop = examplesSection.getBoundingClientRect().top;
		const viewportHeight = window.innerHeight;

		// Show button when examples are below the fold (not visible yet)
		// Hide when examples section is visible in viewport
		if (examplesTop > viewportHeight) {
			examplesBtn.classList.add('visible');
		} else {
			examplesBtn.classList.remove('visible');
		}
	}

	// Throttled scroll handler
	let ticking = false;
	window.addEventListener('scroll', function() {
		if (!ticking) {
			window.requestAnimationFrame(function() {
				updateScrollState();
				updateExamplesButtonVisibility();
				ticking = false;
			});
			ticking = true;
		}
	});

	// Initial check
	updateScrollState();
	updateExamplesButtonVisibility();

	// Helper function to expand a union variants container and all its ancestors
	function expandUnionContainer(container) {
		if (!container) return;

		const toggleBtn = container.querySelector(':scope > .union-collapse-toggle > .union-group-toggle');
		const variantsContent = container.querySelector(':scope > .union-variants-content');

		container.classList.remove('collapsed');
		container.classList.add('expanded');

		if (toggleBtn) {
			const toggleIcon = toggleBtn.querySelector('.toggle-icon');
			const toggleLabel = toggleBtn.querySelector('.toggle-label');
			const optionCount = toggleLabel?.textContent?.match(/\d+/)?.[0] || '';
			if (toggleIcon) toggleIcon.textContent = '−';
			if (toggleLabel) toggleLabel.textContent = `Hide ${optionCount} type options`;
		}

		if (variantsContent) {
			variantsContent.removeAttribute('hidden');
		}

		// Recursively expand parent items
		const parentItem = container.parentElement?.closest('.property-item, .union-variant-item');
		if (parentItem) {
			if (parentItem.classList.contains('union-variant-item')) {
				expandUnionVariantItem(parentItem);
			} else {
				expandPropertyItem(parentItem);
			}
		}
	}

	// Add beforematch event listeners for union variants content
	if (supportsHiddenUntilFound) {
		section.querySelectorAll('.union-variants-content[hidden="until-found"]').forEach(variantsContent => {
			variantsContent.addEventListener('beforematch', function(e) {
				const container = variantsContent.parentElement;
				if (container?.classList.contains('union-variants-container')) {
					expandUnionContainer(container);
				}
			});
		});
	}

	section.addEventListener('click', function(e) {
		// Handle union group toggle buttons (collapse/expand all union options)
		const unionGroupToggle = e.target.closest('.union-group-toggle');
		if (unionGroupToggle) {
			e.preventDefault();
			e.stopPropagation();

			const container = unionGroupToggle.closest('.union-variants-container');
			if (!container) return;

			const isExpanded = container.classList.contains('expanded');
			const toggleIcon = unionGroupToggle.querySelector('.toggle-icon');
			const toggleLabel = unionGroupToggle.querySelector('.toggle-label');
			const variantsContent = container.querySelector(':scope > .union-variants-content');
			const optionCount = toggleLabel?.textContent?.match(/\d+/)?.[0] || '';

			if (isExpanded) {
				container.classList.remove('expanded');
				container.classList.add('collapsed');
				if (toggleIcon) toggleIcon.textContent = '+';
				if (toggleLabel) toggleLabel.textContent = `Show ${optionCount} type options`;
				if (variantsContent && supportsHiddenUntilFound) {
					variantsContent.setAttribute('hidden', 'until-found');
				}
			} else {
				container.classList.remove('collapsed');
				container.classList.add('expanded');
				if (toggleIcon) toggleIcon.textContent = '−';
				if (toggleLabel) toggleLabel.textContent = `Hide ${optionCount} type options`;
				if (variantsContent) {
					variantsContent.removeAttribute('hidden');
				}
			}
			return;
		}

		// Handle section navigation buttons
		const navBtn = e.target.closest('.section-nav-btn');
		if (navBtn) {
			e.preventDefault();
			e.stopPropagation();

			const direction = navBtn.getAttribute('data-dir');
			const headers = Array.from(section.querySelectorAll('h3.section-header'));
			const currentHeader = navBtn.closest('h3');
			const currentIndex = headers.indexOf(currentHeader);

			if (currentIndex === -1) return;

			let targetIndex;
			if (direction === 'up') {
				targetIndex = currentIndex > 0 ? currentIndex - 1 : headers.length - 1;
			} else {
				targetIndex = currentIndex < headers.length - 1 ? currentIndex + 1 : 0;
			}

			const targetHeader = headers[targetIndex];
			if (targetHeader) {
				const offset = 80;
				const targetPosition = targetHeader.getBoundingClientRect().top + window.scrollY - offset;
				window.scrollTo({ top: targetPosition, behavior: 'smooth' });
			}
			return;
		}

		// Handle expand/collapse toggle buttons
		const toggleBtn = e.target.closest('.expand-toggle');
		if (toggleBtn) {
			e.preventDefault();
			e.stopPropagation();

			// Check if this is a union variant toggle (inside .union-expand-toggle)
			const unionToggleRow = toggleBtn.closest('.union-expand-toggle');
			if (unionToggleRow) {
				// Handle union variant expand/collapse - toggle the variant item, not the parent property
				const unionVariantItem = toggleBtn.closest('.union-variant-item');
				if (!unionVariantItem) return;

				const isExpanded = unionVariantItem.classList.contains('expanded');
				const toggleIcon = toggleBtn.querySelector('.toggle-icon');
				const toggleLabel = toggleBtn.querySelector('.toggle-label');
				const nestedProps = unionVariantItem.querySelector(':scope > .nested-properties');
				const propCount = toggleLabel?.textContent?.match(/\d+/)?.[0] || '';

				if (isExpanded) {
					unionVariantItem.classList.remove('expanded');
					unionVariantItem.classList.add('collapsed');
					if (toggleIcon) toggleIcon.textContent = '+';
					if (toggleLabel) toggleLabel.textContent = `Show ${propCount} properties`;
					// Set hidden="until-found" for find-in-page searchability
					if (nestedProps && supportsHiddenUntilFound) {
						nestedProps.setAttribute('hidden', 'until-found');
					}
				} else {
					unionVariantItem.classList.remove('collapsed');
					unionVariantItem.classList.add('expanded');
					if (toggleIcon) toggleIcon.textContent = '−';
					if (toggleLabel) toggleLabel.textContent = `Hide ${propCount} properties`;
					// Remove hidden attribute when expanding
					if (nestedProps) {
						nestedProps.removeAttribute('hidden');
					}
				}
				return;
			}

			// Handle regular property expand/collapse
			const propertyItem = toggleBtn.closest('.property-item');
			if (!propertyItem) return;

			const isExpanded = propertyItem.classList.contains('expanded');
			const toggleIcon = toggleBtn.querySelector('.toggle-icon');
			const nestedProps = propertyItem.querySelector(':scope > .nested-properties');

			const toggleLabel = toggleBtn.querySelector('.toggle-label');
			const propCount = toggleLabel?.textContent?.match(/\d+/)?.[0] || '';

			if (isExpanded) {
				propertyItem.classList.remove('expanded');
				propertyItem.classList.add('collapsed');
				toggleBtn.setAttribute('aria-expanded', 'false');
				if (toggleIcon) toggleIcon.textContent = '+';
				if (toggleLabel) toggleLabel.textContent = `Show ${propCount} properties`;
				// Set hidden="until-found" for find-in-page searchability
				if (nestedProps && supportsHiddenUntilFound) {
					nestedProps.setAttribute('hidden', 'until-found');
				}
			} else {
				propertyItem.classList.remove('collapsed');
				propertyItem.classList.add('expanded');
				toggleBtn.setAttribute('aria-expanded', 'true');
				if (toggleIcon) toggleIcon.textContent = '−';
				if (toggleLabel) toggleLabel.textContent = `Hide ${propCount} properties`;
				// Remove hidden attribute when expanding
				if (nestedProps) {
					nestedProps.removeAttribute('hidden');
				}
			}
		}
	});
})();
</script>

