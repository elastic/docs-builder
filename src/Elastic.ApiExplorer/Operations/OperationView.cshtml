@using Elastic.ApiExplorer.Landing
@using Elastic.ApiExplorer.Operations
@using Microsoft.OpenApi
@inherits RazorSliceHttpResult<Elastic.ApiExplorer.Operations.OperationViewModel>
@implements IUsesLayout<Elastic.ApiExplorer._Layout, ApiLayoutViewModel>
@functions {
	public ApiLayoutViewModel LayoutModel => Model.CreateGlobalLayoutModel();

	private const int MaxDepth = 4;

	// Types that are known to be value types (resolve to primitives like string)
	private static readonly HashSet<string> KnownValueTypes = new(StringComparer.OrdinalIgnoreCase)
	{
		"Field", "Fields", "Id", "Ids", "IndexName", "Indices", "Name", "Names",
		"Routing", "VersionNumber", "SequenceNumber", "PropertyName", "RelationName",
		"TaskId", "ScrollId", "SuggestionName", "Duration", "DateMath", "Fuzziness",
		"GeoHashPrecision", "Distance", "TimeOfDay", "MinimumShouldMatch", "Script",
		"ByteSize", "Percentage", "Stringifiedboolean", "ExpandWildcards", "float", "Stringifiedinteger",
		// Numeric value types
		"uint", "ulong", "long", "int", "short", "ushort", "byte", "sbyte", "double", "decimal"
	};

	// Types that have dedicated pages we can link to
	// Only container types get their own pages - individual queries/aggregations are rendered inline
	private static readonly HashSet<string> LinkedTypes = new(StringComparer.OrdinalIgnoreCase)
	{
		"QueryContainer", "AggregationContainer", "Aggregate"
	};

	private static string GetContainerPageUrl(string typeName)
	{
		// Only container types get their own pages
		return typeName switch
		{
			"QueryContainer" => "/api/elasticsearch/types/_types-query_dsl-querycontainer",
			"AggregationContainer" => "/api/elasticsearch/types/_types-aggregations-aggregationcontainer",
			"Aggregate" => "/api/elasticsearch/types/_types-aggregations-aggregate",
			_ => null! // Should not be called for non-container types
		};
	}

	private static bool ShouldLinkToContainerPage(string typeName)
	{
		// Only actual container types have dedicated pages
		return LinkedTypes.Contains(typeName);
	}

	public string GetPrimitiveTypeName(JsonSchemaType? type)
	{
		if (type is null)
			return "";

		var typeName = "";
		if (type.Value.HasFlag(JsonSchemaType.Boolean))
			typeName = "boolean";
		else if (type.Value.HasFlag(JsonSchemaType.Integer))
			typeName = "integer";
		else if (type.Value.HasFlag(JsonSchemaType.String))
			typeName = "string";
		else if (type.Value.HasFlag(JsonSchemaType.Number))
			typeName = "number";
		else if (type.Value.HasFlag(JsonSchemaType.Null))
			typeName = "null";
		else if (type.Value.HasFlag(JsonSchemaType.Object))
			typeName = "object";

		return typeName;
	}

	public string FormatSchemaName(string schemaId)
	{
		var parts = schemaId.Split('.');
		return parts.Length > 0 ? parts[^1] : schemaId;
	}

	public bool IsValueType(string typeName) => KnownValueTypes.Contains(typeName);

	public bool IsLinkedType(string typeName) => ShouldLinkToContainerPage(typeName);

	public string? GetValueTypeBase(IOpenApiSchema? schema)
	{
		if (schema is null) return null;

		// Check the schema's type
		var primitiveType = GetPrimitiveTypeName(schema.Type);
		if (!string.IsNullOrEmpty(primitiveType) && primitiveType != "object")
			return primitiveType;

		return null;
	}

	public record TypeInfo(
		string TypeName,
		string? SchemaRef,
		bool IsArray,
		bool IsObject,
		bool IsValueType,
		string? ValueTypeBase,
		bool HasLink,
		List<(string Name, string? Ref, bool IsObject)>? AnyOfOptions,
		bool IsDictionary = false,
		IOpenApiSchema? DictValueSchema = null,
		bool IsEnum = false,
		bool IsUnion = false,
		string[]? EnumValues = null,
		string[]? UnionOptions = null
	);

	public TypeInfo GetTypeInfo(IOpenApiSchema? schema, string? currentPropertyPath = null)
	{
		if (schema is null)
			return new TypeInfo("unknown", null, false, false, false, null, false, null);

		// Check if this is a schema reference
		if (schema is OpenApiSchemaReference schemaRef)
		{
			var refId = schemaRef.Reference?.Id;
			if (!string.IsNullOrEmpty(refId))
			{
				var typeName = FormatSchemaName(refId);
				var isArray = schema.Type?.HasFlag(JsonSchemaType.Array) ?? false;
				var isValueType = IsValueType(typeName);
				var valueTypeBase = isValueType ? GetValueTypeBase(schemaRef) ?? "string" : null;
				var hasLink = IsLinkedType(typeName);

				// Check if the schema reference is an enum or union
				// OpenApiSchemaReference proxies to resolved schema properties
				var isEnum = schemaRef.Enum is { Count: > 0 };
				var isUnion = !isEnum && (schemaRef.OneOf is { Count: > 0 } || schemaRef.AnyOf is { Count: > 0 });
				string[]? enumValues = isEnum ? schemaRef.Enum?.Select(e => e?.ToString() ?? "").ToArray() : null;

				// Get union options from oneOf/anyOf
				string[]? unionOptions = null;
				if (isUnion)
				{
					var unionSchemas = schemaRef.OneOf is { Count: > 0 } ? schemaRef.OneOf : schemaRef.AnyOf;
					var options = new List<string>();
					foreach (var s in unionSchemas ?? [])
					{
						if (s is OpenApiSchemaReference unionRef)
						{
							options.Add(FormatSchemaName(unionRef.Reference?.Id ?? "unknown"));
						}
						else if (s?.Enum is { Count: > 0 } inlineEnum)
						{
							// String literal union - add enum values
							foreach (var enumVal in inlineEnum)
								options.Add(enumVal?.ToString() ?? "");
						}
						else
						{
							options.Add(GetPrimitiveTypeName(s?.Type) ?? "unknown");
						}
					}
					unionOptions = options.ToArray();
				}

				return new TypeInfo(typeName, refId, isArray, !isValueType && !isEnum, isValueType, valueTypeBase, hasLink, null, false, null, isEnum, isUnion, enumValues, unionOptions);
			}
		}

		// Check for oneOf/anyOf which often indicate union types
		if (schema.OneOf is { Count: > 0 } oneOf)
		{
			var options = oneOf.Where(s => s is not null).Select(s => {
				var info = GetTypeInfo(s);
				return (info.TypeName, info.SchemaRef, info.IsObject);
			}).ToList();

			var hasObjectOptions = options.Any(o => o.IsObject);
			if (hasObjectOptions && options.Count > 1)
			{
				// Return anyOf options for potential tab rendering
				return new TypeInfo("oneOf", null, false, true, false, null, false, options);
			}

			var typeNames = options.Select(o => o.TypeName).Distinct().ToArray();
			return new TypeInfo(string.Join(" | ", typeNames), null, false, false, false, null, false, null);
		}

		if (schema.AnyOf is { Count: > 0 } anyOf)
		{
			var options = anyOf.Where(s => s is not null).Select(s => {
				var info = GetTypeInfo(s);
				return (info.TypeName, info.SchemaRef, info.IsObject);
			}).ToList();

			var hasObjectOptions = options.Any(o => o.IsObject);
			if (hasObjectOptions && options.Count > 1)
			{
				// Return anyOf options for potential tab rendering
				return new TypeInfo("anyOf", null, false, true, false, null, false, options);
			}

			var typeNames = options.Select(o => o.TypeName).Distinct().ToArray();
			return new TypeInfo(string.Join(" | ", typeNames), null, false, false, false, null, false, null);
		}

		// Check for allOf (usually inheritance/composition)
		if (schema.AllOf is { Count: > 0 } allOf)
		{
			var refSchemas = allOf.OfType<OpenApiSchemaReference>().ToArray();
			if (refSchemas.Length > 0)
			{
				var refId = refSchemas[0].Reference?.Id;
				if (!string.IsNullOrEmpty(refId))
				{
					var typeName = FormatSchemaName(refId);
					var isValueType = IsValueType(typeName);
					var hasLink = IsLinkedType(typeName);
					return new TypeInfo(typeName, refId, false, !isValueType, isValueType, null, hasLink, null);
				}
			}
		}

		// Check for array items
		if (schema.Type?.HasFlag(JsonSchemaType.Array) ?? false)
		{
			if (schema.Items is not null)
			{
				var itemInfo = GetTypeInfo(schema.Items);
				return new TypeInfo(itemInfo.TypeName, itemInfo.SchemaRef, true, itemInfo.IsObject, itemInfo.IsValueType, itemInfo.ValueTypeBase, itemInfo.HasLink, null);
			}
			return new TypeInfo("unknown", null, true, false, false, null, false, null);
		}

		// Check for enum
		if (schema.Enum is { Count: > 0 })
		{
			var enumValues = schema.Enum.Select(e => e?.ToString() ?? "").Take(5).ToArray();
			return new TypeInfo("enum", null, false, false, false, null, false, null, false, null, true, false, enumValues);
		}

		// Check for additionalProperties (dictionary-like objects)
		if (schema.AdditionalProperties is IOpenApiSchema addProps)
		{
			var valueInfo = GetTypeInfo(addProps);
			// Pass valueInfo.HasLink so we know if the dictionary value type has a dedicated page
			return new TypeInfo($"string to {valueInfo.TypeName}", valueInfo.SchemaRef, false, true, false, null, valueInfo.HasLink, null, true, addProps);
		}

		// Check if it has properties (inline object)
		if (schema.Properties is { Count: > 0 })
			return new TypeInfo("object", null, false, true, false, null, false, null);

		// Primitive type
		var primitiveName = GetPrimitiveTypeName(schema.Type);
		if (!string.IsNullOrEmpty(primitiveName))
			return new TypeInfo(primitiveName, null, false, primitiveName == "object", false, null, false, null);

		return new TypeInfo("object", null, false, true, false, null, false, null);
	}

	public IOpenApiSchema? ResolveSchema(IOpenApiSchema? schema)
	{
		if (schema is null) return null;

		// If it's a reference, get the target schema
		if (schema is OpenApiSchemaReference schemaRef)
			return schemaRef;

		// For allOf, merge properties from all schemas
		if (schema.AllOf is { Count: > 0 })
			return schema;

		return schema;
	}

	public IDictionary<string, IOpenApiSchema>? GetSchemaProperties(IOpenApiSchema? schema)
	{
		if (schema is null) return null;

		// Handle schema references - resolve to get actual properties
		if (schema is OpenApiSchemaReference schemaRef)
		{
			var refId = schemaRef.Reference?.Id;
			if (!string.IsNullOrEmpty(refId))
			{
				// Try to get the resolved schema from the document
				if (Model.Document.Components?.Schemas?.TryGetValue(refId, out var resolvedSchema) == true)
				{
					return GetSchemaProperties(resolvedSchema);
				}
			}
			// Fall through to try properties on the reference itself
		}

		// Direct properties
		if (schema.Properties is { Count: > 0 })
			return schema.Properties;

		// For allOf, collect properties from all schemas
		if (schema.AllOf is { Count: > 0 } allOf)
		{
			var props = new Dictionary<string, IOpenApiSchema>();
			foreach (var subSchema in allOf)
			{
				var subProps = GetSchemaProperties(subSchema);
				if (subProps is not null)
				{
					foreach (var prop in subProps)
						props.TryAdd(prop.Key, prop.Value);
				}
			}
			return props.Count > 0 ? props : null;
		}

		return null;
	}

	public IHtmlContent RenderSchemaType(IOpenApiSchema schema, HashSet<string>? ancestorTypes = null)
	{
		var info = GetTypeInfo(schema);
		var sb = new System.Text.StringBuilder();

		// Check if this type actually has properties (for showing {} icon)
		var hasActualProperties = GetSchemaProperties(schema)?.Count > 0;

		// Build the display text with [] for arrays, {} for objects, enum/union markers
		if (info.IsArray)
		{
			sb.Append("<span class=\"array-icon\">[] </span>");
			if (info.IsValueType && info.ValueTypeBase != null)
			{
				sb.Append($"{info.ValueTypeBase} ");
			}
			else if (info.IsEnum)
			{
				sb.Append("<span class=\"enum-icon\">enum </span>");
			}
			else if (info.IsUnion)
			{
				sb.Append("<span class=\"union-icon\">union </span>");
			}
			else if (info.IsObject && !string.IsNullOrEmpty(info.SchemaRef) && (hasActualProperties || info.HasLink))
			{
				sb.Append("<span class=\"object-icon\">{} </span>");
			}
		}
		else if (info.IsDictionary)
		{
			// Dictionary uses a map icon and {} for object value types
			sb.Append("<span class=\"dict-icon\">map </span>");
			var dictValueHasProps = info.DictValueSchema != null && GetSchemaProperties(info.DictValueSchema)?.Count > 0;
			if (info.HasLink || dictValueHasProps)
			{
				sb.Append("<span class=\"object-icon\">{} </span>");
			}
		}
		else if (info.IsEnum)
		{
			// Enum marker
			sb.Append("<span class=\"enum-icon\">enum </span>");
		}
		else if (info.IsUnion)
		{
			// Union marker
			sb.Append("<span class=\"union-icon\">union </span>");
		}
		else if (info.IsValueType && info.ValueTypeBase != null)
		{
			sb.Append($"{info.ValueTypeBase} ");
		}
		else if (info.IsObject && !string.IsNullOrEmpty(info.SchemaRef) && !info.HasLink && hasActualProperties)
		{
			// Regular objects get {} only if they have properties
			sb.Append("<span class=\"object-icon\">{} </span>");
		}

		var displayName = System.Web.HttpUtility.HtmlEncode(info.TypeName);
		var titleAttr = !string.IsNullOrEmpty(info.SchemaRef) ? $" title=\"{info.SchemaRef}\"" : "";

		// Add {} prefix for linked types (they have dedicated pages)
		if (info.HasLink && !info.IsDictionary)
		{
			sb.Append("<span class=\"object-icon\">{} </span>");
		}

		sb.Append($"<span{titleAttr}>{displayName}</span>");

		return new HtmlString($"<code class=\"schema-type\">{sb}</code>");
	}

	public IHtmlContent RenderRecursiveBadge()
	{
		return new HtmlString("<span class=\"recursive\">recursive</span>");
	}

	public IHtmlContent RenderProperties(IOpenApiSchema? schema, ISet<string>? required, string prefix, int depth, HashSet<string>? ancestorTypes = null, bool isRequest = false)
	{
		var properties = GetSchemaProperties(schema);
		if (properties is null || properties.Count == 0)
			return HtmlString.Empty;

		var requiredProps = required ?? schema?.Required ?? new HashSet<string>();
		var propArray = properties.ToArray();

		<dl class="property-list">
			@for (var i = 0; i < propArray.Length; i++)
			{
				var property = propArray[i];
				var propSchema = property.Value;
				if (propSchema is null) continue;
				var isRequired = requiredProps.Contains(property.Key);
				var typeInfo = GetTypeInfo(propSchema);
				var propId = string.IsNullOrEmpty(prefix) ? property.Key : $"{prefix}-{property.Key}";
				var isLast = i == propArray.Length - 1;
				var hasDescription = !string.IsNullOrWhiteSpace(propSchema.Description);

				// Check if this type appears in any ancestor (recursive detection)
				var isRecursive = ancestorTypes != null && !string.IsNullOrEmpty(typeInfo.TypeName) && ancestorTypes.Contains(typeInfo.TypeName);

				// Also check dictionary value types for recursion (e.g., "aggregations" map string to AggregationContainer)
				if (!isRecursive && typeInfo.IsDictionary && typeInfo.DictValueSchema != null)
				{
					var dictValueType = GetTypeInfo(typeInfo.DictValueSchema);
					isRecursive = ancestorTypes != null && !string.IsNullOrEmpty(dictValueType.TypeName) && ancestorTypes.Contains(dictValueType.TypeName);
				}

				// For dictionaries with linked value types, typeInfo.HasLink is true
				var dictHasLinkedValue = typeInfo.IsDictionary && typeInfo.HasLink;

				// Determine if we should show nested properties
				// Don't expand if the type has a dedicated page (linked type)
				var hasNestedProps = typeInfo.IsObject && !typeInfo.HasLink && depth < MaxDepth && GetSchemaProperties(propSchema)?.Count > 0;

				// For dictionaries, check if the value type has properties we should show
				// Don't expand if the value type has a dedicated page (linked type)
				var hasDictValueProps = typeInfo.IsDictionary && typeInfo.DictValueSchema != null
					&& depth < MaxDepth && !dictHasLinkedValue && GetSchemaProperties(typeInfo.DictValueSchema)?.Count > 0;

				// For arrays, check if the item type has properties we should show
				var arrayItemSchema = typeInfo.IsArray && propSchema.Items != null ? propSchema.Items : null;
				var hasArrayItemProps = arrayItemSchema != null && !typeInfo.HasLink && depth < MaxDepth
					&& GetSchemaProperties(arrayItemSchema)?.Count > 0;

				// Count nested properties
				var nestedPropCount = 0;
				if (hasNestedProps)
					nestedPropCount = GetSchemaProperties(propSchema)?.Count ?? 0;
				else if (hasDictValueProps && typeInfo.DictValueSchema != null)
					nestedPropCount = GetSchemaProperties(typeInfo.DictValueSchema)?.Count ?? 0;
				else if (hasArrayItemProps && arrayItemSchema != null)
					nestedPropCount = GetSchemaProperties(arrayItemSchema)?.Count ?? 0;

				// Only show collapse toggle if more than 2 properties
				var hasChildren = (hasNestedProps || hasDictValueProps || hasArrayItemProps) && !isRecursive;
				var isCollapsible = hasChildren && nestedPropCount > 2;

				// Auto expand if < 5 properties, collapse if >= 5
				var defaultExpanded = nestedPropCount > 0 && nestedPropCount < 5;

				<div class="property-item depth-@depth @(isLast ? "last-sibling" : "") @(hasChildren ? "has-children" : "") @(isCollapsible ? (defaultExpanded ? "expanded" : "collapsed") : "")">
					<dt id="@propId">
						<a href="#@propId">
							<code>@property.Key</code>
							@RenderSchemaType(propSchema, ancestorTypes)
							@if (isRequest && isRequired)
							{
								<span class="required">required</span>
							}
							else if (!isRequest && !isRequired)
							{
								<span class="optional">optional</span>
							}
							@if (isRecursive)
							{
								@RenderRecursiveBadge()
							}
						</a>
					</dt>
					@if (hasDescription)
					{
						<dd>
							@Model.RenderMarkdown(propSchema.Description)
						</dd>
					}
					@if (typeInfo.IsEnum && typeInfo.EnumValues is { Length: > 0 })
					{
						<dd class="enum-values">
							<span class="values-label">Values:</span>
							@foreach (var enumVal in typeInfo.EnumValues)
							{
								<code class="enum-value">@enumVal</code>
							}
						</dd>
					}
					@if (typeInfo.IsUnion && typeInfo.UnionOptions is { Length: > 0 })
					{
						<dd class="union-options">
							<span class="values-label">One of:</span>
							@foreach (var unionOpt in typeInfo.UnionOptions)
							{
								<code class="union-option">@unionOpt</code>
							}
						</dd>
					}
					@{
						// Add link to type page for linked types
						var linkedTypeName = typeInfo.HasLink
							? (typeInfo.IsDictionary && typeInfo.DictValueSchema != null
								? GetTypeInfo(typeInfo.DictValueSchema).TypeName
								: typeInfo.TypeName)
							: null;
					}
					@if (!string.IsNullOrEmpty(linkedTypeName))
					{
						var typePageUrl = GetContainerPageUrl(linkedTypeName);
						<dd class="type-link-description">
							<a href="@typePageUrl" data-hx-boost="false">See @linkedTypeName type →</a>
						</dd>
					}
					@if (isCollapsible)
					{
						<dd class="expand-toggle-row">
							<button class="expand-toggle" aria-expanded="@(defaultExpanded ? "true" : "false")" aria-controls="@propId-children" title="@(defaultExpanded ? "Collapse" : "Expand") @nestedPropCount properties">
								<span class="toggle-icon">@(defaultExpanded ? "−" : "+")</span>
								<span class="toggle-label">@(defaultExpanded ? "Hide" : "Show") @nestedPropCount properties</span>
							</button>
						</dd>
					}
					@if (!isRecursive)
					{
						// Build new ancestor set including current type
						var newAncestors = ancestorTypes != null ? new HashSet<string>(ancestorTypes) : new HashSet<string>();
						if (!string.IsNullOrEmpty(typeInfo.TypeName) && typeInfo.IsObject)
						{
							// For dictionaries, add the value type name rather than "string to X"
							if (typeInfo.IsDictionary && typeInfo.DictValueSchema != null)
							{
								var dictValueType = GetTypeInfo(typeInfo.DictValueSchema);
								if (!string.IsNullOrEmpty(dictValueType.TypeName))
									newAncestors.Add(dictValueType.TypeName);
							}
							else
							{
								newAncestors.Add(typeInfo.TypeName);
							}
						}

						if (hasDictValueProps && typeInfo.DictValueSchema != null)
						{
							// Show dictionary with intermediary key level - key is always string for additionalProperties
							var keyPropId = $"{propId}-string";
							<div class="nested-properties" id="@propId-children">
								<dl class="property-list">
									<div class="property-item depth-@(depth + 1) has-children">
										<dt id="@keyPropId">
											<code>&lt;string&gt;</code>
											@RenderSchemaType(typeInfo.DictValueSchema, newAncestors)
										</dt>
										<div class="nested-properties">
											@RenderProperties(typeInfo.DictValueSchema, null, keyPropId, depth + 2, newAncestors, isRequest)
										</div>
									</div>
								</dl>
							</div>
						}
						else if (hasNestedProps)
						{
							<div class="nested-properties" id="@propId-children">
								@RenderProperties(propSchema, null, propId, depth + 1, newAncestors, isRequest)
							</div>
						}
						else if (hasArrayItemProps && arrayItemSchema != null)
						{
							// Show array item properties
							<div class="nested-properties" id="@propId-children">
								@RenderProperties(arrayItemSchema, null, propId, depth + 1, newAncestors, isRequest)
							</div>
						}
					}
				</div>
			}
		</dl>

		return HtmlString.Empty;
	}
}
@{
	var self = Model.CurrentNavigationItem as OperationNavigationItem;
	var allOperations =
		Model.CurrentNavigationItem.Parent is EndpointNavigationItem { NavigationItems.Count: > 0 } parent && parent.NavigationItems.All(n => n.Hidden)
			? parent.NavigationItems
			: self is not null
				? [self]
				: [];

	var operation = Model.Operation.Operation;
}

<section id="elastic-api-v3">
	<h1>@operation.Summary</h1>

	<h3 class="section-header" data-section="paths">
		<span>Paths</span>
		<span class="section-nav">
			<span class="section-path">@Model.Operation.Route</span>
			<button class="section-nav-btn" data-dir="up" title="Previous section">&#x25B2;</button>
			<button class="section-nav-btn" data-dir="down" title="Next section">&#x25BC;</button>
		</span>
	</h3>
	<ul class="api-url-listing">
		@foreach (var overload in allOperations)
		{
			var method = overload.Model.OperationType.ToString().ToLowerInvariant();
			var current = overload.Model.Route == Model.Operation.Route && overload.Model.OperationType == Model.Operation.OperationType ? "current" : "";
			<li class="api-url-list-item">
				<a href="@overload.Url" class="@current" hx-disable="true">
					 <span class="api-method api-method-@method">@method.ToUpperInvariant()</span>
					 <span class="api-url">@overload.Model.Route</span>
				</a>
			</li>
		}
	</ul>
	@{
		var pathParameters = operation.Parameters?.Where(p => p.In == ParameterLocation.Path).ToArray() ?? [];
	}
	@if (pathParameters.Length > 0)
	{
		<h4>Path Parameters</h4>
		<dl class="property-list">
		@foreach (var path in pathParameters)
		{
			<dt id="path-@path.Name"><a href="#path-@path.Name"><code>@path.Name</code></a></dt>
			<dd>@Model.RenderMarkdown(path.Description)</dd>
		}
		</dl>
	}

	@if (!string.IsNullOrWhiteSpace(operation.Description))
	{
		<h3 class="section-header" data-section="description">
			<span>Description</span>
			<span class="section-nav">
				<span class="section-path">@Model.Operation.Route</span>
				<button class="section-nav-btn" data-dir="up" title="Previous section">&#x25B2;</button>
				<button class="section-nav-btn" data-dir="down" title="Next section">&#x25BC;</button>
			</span>
		</h3>
		<p>
			@(Model.RenderMarkdown(operation.Description))
		</p>
	}

	@{
		var queryStringParameters = operation.Parameters?.Where(p => p.In == ParameterLocation.Query).ToArray() ?? [];
	}
	@if (queryStringParameters.Length > 0)
	{
		<h3 class="section-header" data-section="query-params">
			<span>Query String Parameters</span>
			<span class="section-nav">
				<span class="section-path">@Model.Operation.Route</span>
				<button class="section-nav-btn" data-dir="up" title="Previous section">&#x25B2;</button>
				<button class="section-nav-btn" data-dir="down" title="Next section">&#x25BC;</button>
			</span>
		</h3>
		<dl class="property-list">
			@foreach (var qs in queryStringParameters)
			{
				<dt id="query-@qs.Name"><a href="#query-@qs.Name"><code>@qs.Name</code></a></dt>
				<dd>@Model.RenderMarkdown(qs.Description)</dd>
			}
		</dl>
	}
	@if (operation.RequestBody is not null)
	{
		var requestContent = operation.RequestBody.Content?.FirstOrDefault();
		var requestContentType = requestContent?.Key ?? "application/json";
		<h3 class="section-header" data-section="request-body">
			<span>Request Body</span>
			<span class="content-type-badge">@requestContentType</span>
			<span class="section-nav">
				<span class="section-path">@Model.Operation.Route</span>
				<button class="section-nav-btn" data-dir="up" title="Previous section">&#x25B2;</button>
				<button class="section-nav-btn" data-dir="down" title="Next section">&#x25BC;</button>
			</span>
		</h3>
		var content = requestContent?.Value;
		if (!string.IsNullOrEmpty(operation.RequestBody.Description))
		{
			<p>@Model.RenderMarkdown(operation.RequestBody.Description)</p>
		}

		var requestSchema = content?.Schema;
		if (requestSchema is not null)
		{
			var props = GetSchemaProperties(requestSchema);
			if (props is { Count: > 0 })
			{
				@RenderProperties(requestSchema, null, "req", 0, null, isRequest: true)
			}
			else
			{
				<p>Type: @RenderSchemaType(requestSchema)</p>
			}
		}
	}

	@if (operation.Responses is { Count: > 0 })
	{
		var isSingleResponse = operation.Responses.Count == 1;
		var singleResponse = isSingleResponse ? operation.Responses.First() : default;
		var singleContentType = isSingleResponse && singleResponse.Value?.Content?.Count > 0
			? singleResponse.Value.Content.First().Key
			: null;

		<h3 class="section-header" data-section="responses">
			<span>@(isSingleResponse ? "Response" : "Responses")</span>
			@if (!string.IsNullOrEmpty(singleContentType))
			{
				<span class="content-type-badge">@singleContentType</span>
			}
			<span class="section-nav">
				<span class="section-path">@Model.Operation.Route</span>
				<button class="section-nav-btn" data-dir="up" title="Previous section">&#x25B2;</button>
				<button class="section-nav-btn" data-dir="down" title="Next section">&#x25BC;</button>
			</span>
		</h3>
		@foreach (var response in operation.Responses)
		{
			var statusCode = response.Key;
			var responseValue = response.Value;
			if (responseValue is null) continue;
			var statusClass = statusCode.StartsWith("2") ? "success" : statusCode.StartsWith("4") || statusCode.StartsWith("5") ? "error" : "info";
			<div class="response-section">
				@if (!isSingleResponse)
				{
					<h4>
						<span class="status-code status-@statusClass">@statusCode</span>
						@if (!string.IsNullOrEmpty(responseValue.Description))
						{
							<span class="response-description">@responseValue.Description</span>
						}
					</h4>
				}
				@if (responseValue.Content is { Count: > 0 })
				{
					foreach (var contentType in responseValue.Content)
					{
						if (contentType.Value?.Schema is not { } responseSchema) continue;
						@if (!isSingleResponse)
						{
							<p class="content-type">Content-Type: <code>@contentType.Key</code></p>
						}
						var responseProps = GetSchemaProperties(responseSchema);
						if (responseProps is { Count: > 0 })
						{
							@RenderProperties(responseSchema, null, $"res-{statusCode}", 0)
						}
						else
						{
							<p>Response Type: @RenderSchemaType(responseSchema)</p>
						}
					}
				}
			</div>
		}
	}
	@{
		// Check for examples in request body
		var requestBodyContent = operation.RequestBody?.Content?.FirstOrDefault().Value;
		var requestExamples = requestBodyContent?.Examples;

		// Check for examples in the response
		var successResponse = operation.Responses?.FirstOrDefault(r => r.Key.StartsWith("2")).Value;
		var responseContent = successResponse?.Content?.FirstOrDefault().Value;
		var responseExamples = responseContent?.Examples;
	}
	@if (requestExamples is { Count: > 0 })
	{
		<h3 class="section-header" data-section="request-examples">
			<span>Request Examples</span>
			<span class="section-nav">
				<span class="section-path">@Model.Operation.Route</span>
				<button class="section-nav-btn" data-dir="up" title="Previous section">&#x25B2;</button>
				<button class="section-nav-btn" data-dir="down" title="Next section">&#x25BC;</button>
			</span>
		</h3>
		@foreach (var example in requestExamples)
		{
			<div class="example-block">
				<h4>@(string.IsNullOrEmpty(example.Value?.Summary) ? example.Key : example.Value.Summary)</h4>
				@if (!string.IsNullOrEmpty(example.Value?.Description))
				{
					<div class="example-description">@Model.RenderMarkdown(example.Value.Description)</div>
				}
				@if (example.Value?.Value is not null)
				{
					<pre><code class="language-json">@example.Value.Value.ToString()</code></pre>
				}
				@if (!string.IsNullOrEmpty(example.Value?.ExternalValue))
				{
					<p class="external-example">External example: <a href="@example.Value.ExternalValue">@example.Value.ExternalValue</a></p>
				}
			</div>
		}
	}
	@if (responseExamples is { Count: > 0 })
	{
		<h3 class="section-header" data-section="response-examples">
			<span>Response Examples</span>
			<span class="section-nav">
				<span class="section-path">@Model.Operation.Route</span>
				<button class="section-nav-btn" data-dir="up" title="Previous section">&#x25B2;</button>
				<button class="section-nav-btn" data-dir="down" title="Next section">&#x25BC;</button>
			</span>
		</h3>
		@foreach (var example in responseExamples)
		{
			<div class="example-block">
				<h4>@(string.IsNullOrEmpty(example.Value?.Summary) ? example.Key : example.Value.Summary)</h4>
				@if (!string.IsNullOrEmpty(example.Value?.Description))
				{
					<div class="example-description">@Model.RenderMarkdown(example.Value.Description)</div>
				}
				@if (example.Value?.Value is not null)
				{
					<pre><code class="language-json">@example.Value.Value.ToString()</code></pre>
				}
				@if (!string.IsNullOrEmpty(example.Value?.ExternalValue))
				{
					<p class="external-example">External example: <a href="@example.Value.ExternalValue">@example.Value.ExternalValue</a></p>
				}
			</div>
		}
	}
</section>

<script>
(function() {
	// Use event delegation on the section
	const section = document.getElementById('elastic-api-v3');
	if (!section) return;

	// Scroll detection for section-path visibility
	// Find the trigger point - after Path Parameters header (or paths section if no path params)
	let triggerElement = null;

	// First check for Path Parameters header
	const pathParamsHeader = section.querySelector('h4');
	if (pathParamsHeader && pathParamsHeader.textContent?.includes('Path Parameters')) {
		triggerElement = pathParamsHeader;
	} else {
		// Fall back to the paths section URL listing
		const pathsHeader = section.querySelector('h3[data-section="paths"]');
		if (pathsHeader) {
			triggerElement = pathsHeader.nextElementSibling;
		}
	}

	function updateScrollState() {
		if (!triggerElement) return;

		const triggerBottom = triggerElement.getBoundingClientRect().bottom;
		const isScrolled = triggerBottom < 100; // 100px from top of viewport

		section.querySelectorAll('h3.section-header').forEach(header => {
			if (isScrolled) {
				header.classList.add('scrolled');
			} else {
				header.classList.remove('scrolled');
			}
		});
	}

	// Throttled scroll handler
	let ticking = false;
	window.addEventListener('scroll', function() {
		if (!ticking) {
			window.requestAnimationFrame(function() {
				updateScrollState();
				ticking = false;
			});
			ticking = true;
		}
	});

	// Initial check
	updateScrollState();

	section.addEventListener('click', function(e) {
		// Handle section navigation buttons
		const navBtn = e.target.closest('.section-nav-btn');
		if (navBtn) {
			e.preventDefault();
			e.stopPropagation();

			const direction = navBtn.getAttribute('data-dir');
			const headers = Array.from(section.querySelectorAll('h3.section-header'));
			const currentHeader = navBtn.closest('h3');
			const currentIndex = headers.indexOf(currentHeader);

			if (currentIndex === -1) return;

			let targetIndex;
			if (direction === 'up') {
				targetIndex = currentIndex > 0 ? currentIndex - 1 : headers.length - 1;
			} else {
				targetIndex = currentIndex < headers.length - 1 ? currentIndex + 1 : 0;
			}

			const targetHeader = headers[targetIndex];
			if (targetHeader) {
				const offset = 80;
				const targetPosition = targetHeader.getBoundingClientRect().top + window.scrollY - offset;
				window.scrollTo({ top: targetPosition, behavior: 'smooth' });
			}
			return;
		}

		// Handle expand/collapse toggle buttons
		const toggleBtn = e.target.closest('.expand-toggle');
		if (toggleBtn) {
			e.preventDefault();
			e.stopPropagation();

			const propertyItem = toggleBtn.closest('.property-item');
			if (!propertyItem) return;

			const isExpanded = propertyItem.classList.contains('expanded');
			const toggleIcon = toggleBtn.querySelector('.toggle-icon');

			const toggleLabel = toggleBtn.querySelector('.toggle-label');
			const propCount = toggleLabel?.textContent?.match(/\d+/)?.[0] || '';

			if (isExpanded) {
				propertyItem.classList.remove('expanded');
				propertyItem.classList.add('collapsed');
				toggleBtn.setAttribute('aria-expanded', 'false');
				if (toggleIcon) toggleIcon.textContent = '+';
				if (toggleLabel) toggleLabel.textContent = `Show ${propCount} properties`;
			} else {
				propertyItem.classList.remove('collapsed');
				propertyItem.classList.add('expanded');
				toggleBtn.setAttribute('aria-expanded', 'true');
				if (toggleIcon) toggleIcon.textContent = '−';
				if (toggleLabel) toggleLabel.textContent = `Hide ${propCount} properties`;
			}
		}
	});
})();
</script>

