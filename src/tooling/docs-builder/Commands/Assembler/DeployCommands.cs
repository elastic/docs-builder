// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information

using System.IO.Abstractions;
using Actions.Core.Services;
using ConsoleAppFramework;
using Elastic.Documentation.Assembler.Deploying;
using Elastic.Documentation.Configuration;
using Elastic.Documentation.Configuration.Assembler;
using Elastic.Documentation.Diagnostics;
using Elastic.Documentation.Services;
using Microsoft.Extensions.Logging;

namespace Documentation.Builder.Commands.Assembler;

internal sealed class DeployCommands(
	AssemblyConfiguration assemblyConfiguration,
	IDiagnosticsCollector collector,
	IConfigurationContext configurationContext,
	ILoggerFactory logFactory,
	ICoreService githubActionsService
)
{
	/// <summary> Creates a sync plan </summary>
	/// <param name="environment"> The environment to build</param>
	/// <param name="s3BucketName">The S3 bucket name to deploy to</param>
	/// <param name="out"> The file to write the plan to</param>
	/// <param name="deleteThreshold"> The percentage of deletions allowed in the plan as float</param>
	/// <param name="ctx"></param>
	[Command("plan")]
	public async Task<int> Plan(string environment, string s3BucketName, string @out = "", float? deleteThreshold = null, Cancel ctx = default)
	{
		await using var serviceInvoker = new ServiceInvoker(collector);

		var fs = new FileSystem();
		var service = new IncrementalDeployService(logFactory, assemblyConfiguration, configurationContext, githubActionsService, fs);
		serviceInvoker.AddCommand(service, (environment, s3BucketName, @out, deleteThreshold),
			static async (s, collector, state, ctx) => await s.Plan(collector, state.environment, state.s3BucketName, state.@out, state.deleteThreshold, ctx)
		);
		return await serviceInvoker.InvokeAsync(ctx);
	}

	/// <summary> Applies a sync plan </summary>
	/// <param name="environment"> The environment to build</param>
	/// <param name="s3BucketName">The S3 bucket name to deploy to</param>
	/// <param name="planFile">The file path to the plan file to apply</param>
	/// <param name="ctx"></param>
	[Command("apply")]
	public async Task<int> Apply(string environment, string s3BucketName, string planFile, Cancel ctx = default)
	{
		await using var serviceInvoker = new ServiceInvoker(collector);

		var fs = new FileSystem();
		var service = new IncrementalDeployService(logFactory, assemblyConfiguration, configurationContext, githubActionsService, fs);
		serviceInvoker.AddCommand(service, (environment, s3BucketName, planFile),
			static async (s, collector, state, ctx) => await s.Apply(collector, state.environment, state.s3BucketName, state.planFile, ctx)
		);
		return await serviceInvoker.InvokeAsync(ctx);
	}

	/// <summary>Refreshes the redirects mapping in Cloudfront's KeyValueStore</summary>
	/// <param name="environment">The environment to build</param>
	/// <param name="redirectsFile">Path to the redirects mapping pre-generated by docs-builder assemble</param>
	/// <param name="ctx"></param>
	[Command("update-redirects")]
	public async Task<int> UpdateRedirects(string environment, string? redirectsFile = null, Cancel ctx = default)
	{
		await using var serviceInvoker = new ServiceInvoker(collector);

		var fs = new FileSystem();
		var service = new DeployUpdateRedirectsService(logFactory, fs);
		serviceInvoker.AddCommand(service, (environment, redirectsFile),
			static async (s, collector, state, ctx) => await s.UpdateRedirects(collector, state.environment, state.redirectsFile, ctx)
		);
		return await serviceInvoker.InvokeAsync(ctx);
	}

}
