// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information

using System.Diagnostics.CodeAnalysis;
using System.IO.Abstractions;
using System.Text.Json;
using Actions.Core.Services;
using Amazon.CloudFront;
using Amazon.CloudFrontKeyValueStore;
using Amazon.CloudFrontKeyValueStore.Model;
using Amazon.S3;
using Amazon.S3.Transfer;
using ConsoleAppFramework;
using Documentation.Assembler.Deploying;
using Elastic.Documentation.Serialization;
using Elastic.Documentation.Tooling.Diagnostics.Console;
using Elastic.Documentation.Tooling.Filters;
using Microsoft.Extensions.Logging;

namespace Documentation.Assembler.Cli;

internal enum KvsOperation
{
	Puts,
	Deletes
}

internal sealed class DeployCommands(ILoggerFactory logger, ICoreService githubActionsService)
{
	[SuppressMessage("Usage", "CA2254:Template should be a static expression")]
	private void AssignOutputLogger()
	{
		var log = logger.CreateLogger<Program>();
		ConsoleApp.Log = msg => log.LogInformation(msg);
		ConsoleApp.LogError = msg => log.LogError(msg);
	}

	/// <summary> Creates a sync plan </summary>
	/// <param name="environment"> The environment to build</param>
	/// <param name="s3BucketName">The S3 bucket name to deploy to</param>
	/// <param name="out"> The file to write the plan to</param>
	/// <param name="ctx"></param>
	public async Task<int> Plan(
		string environment, string s3BucketName, string @out = "", Cancel ctx = default)
	{
		AssignOutputLogger();
		await using var collector = new ConsoleDiagnosticsCollector(logger, githubActionsService)
		{
			NoHints = true
		}.StartAsync(ctx);
		var assembleContext = new AssembleContext(environment, collector, new FileSystem(), new FileSystem(), null, null);
		var s3Client = new AmazonS3Client();
		IDocsSyncPlanStrategy planner = new AwsS3SyncPlanStrategy(s3Client, s3BucketName, assembleContext, logger);
		var plan = await planner.Plan(ctx);
		ConsoleApp.Log("Total files to sync: " + plan.Count);
		ConsoleApp.Log("Total files to delete: " + plan.DeleteRequests.Count);
		ConsoleApp.Log("Total files to add: " + plan.AddRequests.Count);
		ConsoleApp.Log("Total files to update: " + plan.UpdateRequests.Count);
		ConsoleApp.Log("Total files to skip: " + plan.SkipRequests.Count);
		if (!string.IsNullOrEmpty(@out))
		{
			var output = SyncPlan.Serialize(plan);
			await using var fileStream = new FileStream(@out, FileMode.Create, FileAccess.Write);
			await using var writer = new StreamWriter(fileStream);
			await writer.WriteAsync(output);
			ConsoleApp.Log("Plan written to " + @out);
		}
		await collector.StopAsync(ctx);
		return collector.Errors;
	}

	/// <summary> Applies a sync plan </summary>
	/// <param name="environment"> The environment to build</param>
	/// <param name="s3BucketName">The S3 bucket name to deploy to</param>
	/// <param name="planFile">The path to the plan file to apply</param>
	/// <param name="ctx"></param>
	public async Task<int> Apply(
		string environment,
		string s3BucketName,
		string planFile,
		Cancel ctx = default)
	{
		AssignOutputLogger();
		await using var collector = new ConsoleDiagnosticsCollector(logger, githubActionsService)
		{
			NoHints = true
		}.StartAsync(ctx);
		var assembleContext = new AssembleContext(environment, collector, new FileSystem(), new FileSystem(), null, null);
		var s3Client = new AmazonS3Client();
		var transferUtility = new TransferUtility(s3Client, new TransferUtilityConfig
		{
			ConcurrentServiceRequests = Environment.ProcessorCount * 2,
			MinSizeBeforePartUpload = AwsS3SyncPlanStrategy.PartSize
		});
		IDocsSyncApplyStrategy applier = new AwsS3SyncApplyStrategy(s3Client, transferUtility, s3BucketName, assembleContext, logger, collector);
		if (!File.Exists(planFile))
		{
			collector.EmitError(planFile, "Plan file does not exist.");
			await collector.StopAsync(ctx);
			return collector.Errors;
		}
		var planJson = await File.ReadAllTextAsync(planFile, ctx);
		var plan = SyncPlan.Deserialize(planJson);
		await applier.Apply(plan, ctx);
		await collector.StopAsync(ctx);
		return collector.Errors;
	}

	/// <summary>Refreshes the redirects mapping in Cloudfront's KeyValueStore</summary>
	/// <param name="environment">The environment to build</param>
	/// <param name="redirectsFile">Path to the redirects mapping pre-generated by docs-assembler</param>
	/// <param name="ctx"></param>
	[Command("update-redirects")]
	[ConsoleAppFilter<StopwatchFilter>]
	[ConsoleAppFilter<CatchExceptionFilter>]
	public async Task<int> UpdateRedirects(
		string environment,
		string redirectsFile = ".artifacts/assembly/redirects.json",
		Cancel ctx = default)
	{
		AssignOutputLogger();
		await using var collector = new ConsoleDiagnosticsCollector(logger, githubActionsService)
		{
			NoHints = true
		}.StartAsync(ctx);

		if (!File.Exists(redirectsFile))
		{
			collector.EmitError(redirectsFile, "Redirects mapping does not exist.");
			await collector.StopAsync(ctx);
			return collector.Errors;
		}

		ConsoleApp.Log("Parsing redirects mapping");
		var jsonContent = await File.ReadAllTextAsync(redirectsFile, ctx);
		var sourcedRedirects = JsonSerializer.Deserialize(jsonContent, SourceGenerationContext.Default.DictionaryStringString);

		if (sourcedRedirects is null)
		{
			collector.EmitError(redirectsFile, "Redirects mapping is invalid.");
			await collector.StopAsync(ctx);
			return collector.Errors;
		}

		var kvsName = $"elastic-docs-v3-{environment}-redirects-kvs";

		var cfClient = new AmazonCloudFrontClient();
		var kvsClient = new AmazonCloudFrontKeyValueStoreClient();

		ConsoleApp.Log("Describing KVS");
		var describeResponse = await cfClient.DescribeKeyValueStoreAsync(new Amazon.CloudFront.Model.DescribeKeyValueStoreRequest { Name = kvsName }, ctx);

		var kvsArn = describeResponse.KeyValueStore.ARN;
		var eTag = describeResponse.ETag;
		var existingRedirects = new HashSet<string>();

		var listKeysRequest = new ListKeysRequest { KvsARN = kvsArn };
		ListKeysResponse listKeysResponse;

		do
		{
			listKeysResponse = await kvsClient.ListKeysAsync(listKeysRequest, ctx);
			foreach (var item in listKeysResponse.Items)
				_ = existingRedirects.Add(item.Key);
			listKeysRequest.NextToken = listKeysResponse.NextToken;
		}
		while (!string.IsNullOrEmpty(listKeysResponse.NextToken));

		var toPut = sourcedRedirects
			.Select(kvp => new PutKeyRequestListItem { Key = kvp.Key, Value = kvp.Value });
		var toDelete = existingRedirects
			.Except(sourcedRedirects.Keys)
			.Select(k => new DeleteKeyRequestListItem { Key = k });

		ConsoleApp.Log("Updating redirects in KVS");
		const int batchSize = 50;

		eTag = await ProcessBatchUpdatesAsync(kvsClient, kvsArn, eTag, toPut, batchSize, KvsOperation.Puts, ctx);
		_ = await ProcessBatchUpdatesAsync(kvsClient, kvsArn, eTag, toDelete, batchSize, KvsOperation.Deletes, ctx);

		await collector.StopAsync(ctx);
		return collector.Errors;
	}

	private static async Task<string> ProcessBatchUpdatesAsync(
		IAmazonCloudFrontKeyValueStore kvsClient,
		string kvsArn,
		string eTag,
		IEnumerable<object> items,
		int batchSize,
		KvsOperation operation,
		Cancel ctx)
	{
		var enumerable = items.ToList();
		for (var i = 0; i < enumerable.Count; i += batchSize)
		{
			var batch = enumerable.Skip(i).Take(batchSize);
			var updateRequest = new UpdateKeysRequest
			{
				KvsARN = kvsArn,
				IfMatch = eTag
			};

			if (operation is KvsOperation.Puts)
				updateRequest.Puts = batch.Cast<PutKeyRequestListItem>().ToList();
			else if (operation is KvsOperation.Deletes)
				updateRequest.Deletes = batch.Cast<DeleteKeyRequestListItem>().ToList();

			var update = await kvsClient.UpdateKeysAsync(updateRequest, ctx);
			eTag = update.ETag;
		}

		return eTag;
	}

}
